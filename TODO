- all simple_preopt

- cprop for floating-point
- strength reduction
- branch folding

- legalization
  - replace `op_imm` ops with `op` (legalization)
  - heap, table, ...
    - show dedup of parts of heap addr computation
  - i128 -> i64 narrowing?

- perf ideas
  - elaboration
    - find_best_node: stop at sufficiently cheap node? bound the
      search to better than what's found so far?
    - find_best_node: avoid scoped approach; compute best nodes
      independent of what's already available
  - keep Insts (side-effecting ops) in DFG, and just rewrite args and
    attach new results when elaborating.

- code quality
  - strength reduction for mul/div/rem
  - analyses: demanded bits, defined bits
  - more legalizations of pseudoinsts in mid-end, to allow opts
    - handle amodes this way too?
      - in lowering, don't generate new adds; just take pieces of toplevel add
      - then rewrite in mid-end to reassociate as needed
  - amodes
    - aarch64: better to do reg+imm with add-with-sext for heap base +
      wasm ptr
    - aarch64 and x64: don't gen new adds during lowering; instead
      nudge things in right direction in mid-end and just match up the
      tree during lowering
  - redundant flags uses: reconsider iflags?

- features
  - support non-pure nodes in rewrite as well?
    - optimize once before adding to side_effects list
    - handle varargs for calls, branches
  - abstract the notion of an analysis; use for loop-depth
  - use computed loop-depth when elaborating, rather than recomputing
