- all simple_preopt

- cprop for floating-point
- strength reduction
- branch folding

- legalization
  - replace `op_imm` ops with `op` (legalization)
  - heap, table, ...
    - show dedup of parts of heap addr computation
  - i128 -> i64 narrowing?

- perf ideas
  - limit nodes exposed in pure_enodes_etor: pre-extract? "subsume"
    nodes/return from simplify?
    - two rule entry points: "replace" and "simplify". make parent
      pointer in union node "cut-off": we keep the enodes so they will
      dedup into the canonical id but we don't traverse them. (or just
      don't create a union node? union in the UnionFind only?)
  - make alias analysis faster to compute
    - cache predicates? has_side_effect, is_memory_fence, ...
  - elaboration
    - find_best_node: stop at sufficiently cheap node? bound the
      search to better than what's found so far?
    - find_best_node: avoid scoped approach; compute best nodes
      independent of what's already available
  - keep Insts (side-effecting ops) in DFG, and just rewrite args and
    attach new results when elaborating.

  - elaborate: when an Inst node is present, we must select that one;
    other nodes rewriting onto it (unioning with it) don't change
    that. pre-populate best selection.

- code quality
  - strength reduction for mul/div/rem
  - analyses: demanded bits, defined bits
  - more legalizations of pseudoinsts in mid-end, to allow opts
    - handle amodes this way too?
      - in lowering, don't generate new adds; just take pieces of toplevel add
      - then rewrite in mid-end to reassociate as needed

- features
  - support non-pure nodes in rewrite as well?
    - optimize once before adding to side_effects list
    - handle varargs for calls, branches
  - abstract the notion of an analysis; use for loop-depth
  - use computed loop-depth when elaborating, rather than recomputing
