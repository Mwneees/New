- all simple_preopt

- cprop for floating-point
- strength reduction
- branch folding

- legalization
  - replace `op_imm` ops with `op` (legalization)
  - heap, table, ...
    - show dedup of parts of heap addr computation
  - i128 -> i64 narrowing?

- perf ideas
  - limit nodes exposed in pure_enodes_etor: pre-extract? "subsume"
    nodes/return from simplify?
    - two rule entry points: "replace" and "simplify". make parent
      pointer in union node "cut-off": we keep the enodes so they will
      dedup into the canonical id but we don't traverse them. (or just
      don't create a union node? union in the UnionFind only?)
  - make alias analysis faster to compute
    - cache predicates? has_side_effect, is_memory_fence, ...
  - elaboration
    - find_best_node: stop at sufficiently cheap node? bound the
      search to better than what's found so far?
    - find_best_node: avoid scoped approach; compute best nodes
      independent of what's already available
  - keep Insts (side-effecting ops) in DFG, and just rewrite args and
    attach new results when elaborating.

  - elaborate: when an Inst node is present, we must select that one;
    other nodes rewriting onto it (unioning with it) don't change
    that. pre-populate best selection.

- code quality
  - and x, 0xffff....
  - x << N >> N as uextend / sextend
  - strength reduction for mul/div/rem
  - analyses: demanded bits, defined bits
  - immediate reuse within basic blocks
  - remat adds near uses? outside of basic blocks?
  - (icmp (band (iconst 0xffff_ffff) x) ...) -> (icmp $I32 (ireduce x) ...)
  - more legalizations of pseudoinsts in mid-end, to allow opts
    - handle amodes this way too?
