;; Legalizing CLIF to CLIF
;;
;; This file is one of the main entry points for performing "legalizations" that
;; transform CLIF to CLIF to simplify the IR for one phase or another. One
;; example of a legalization is replacing "macro instructions" with their
;; components, such as the `stack_store` CLIF instruction with a `stack_addr`
;; plus a `store`. This way backends don't need to implement lowering for
;; all three instructions, only the latter two.
;;
;; Backends also have their own forms of legalization as well. For example
;; instead of natively implementing a `uextend`-to-128-bits backends can choose
;; to legalize the `uextend` instruction in this case to be replaced with an
;; `iconcat`. This can help reduce the number of lowerings that a backend needs
;; while sharing legalization code with other backends.
;;
;; This file is organized as shared support for all backends. This contains
;; the definition of the `legalize` function which is the main entrypoint for
;; transforming instructions. Some required legalizations are defined in this
;; file such as legalizing the CLIF `stack_store` pseudo-instruction. Otherwise
;; platform-neutral helpers are defined in this file that each backend can
;; opt-in to as desired.

;; ========= Type Definitions =================================================

(type Inst (primitive Inst))
(type CursorPosition (primitive CursorPosition))
(type ExternalName extern (enum))

;; ========= Helper extractors/constructors ===================================

;; Helper used in generated extractors for each CLIF instruction to extract
;; information from an `Inst`.
(decl inst_data (InstructionData) Inst)
(extern extractor infallible inst_data inst_data)

;; Helper used to perform an `ins()` operation which inserts just before the
;; current instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `ins_*` prefix.
(decl ins (Type InstructionData) Inst)
(extern constructor ins ins)

;; Helper used to perform a `replace()` operation which replaces the current
;; instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `replace_*` prefix.
(decl replace (Type InstructionData) Inst)
(extern constructor replace replace)

;; Constructors for value arrays.
(decl value_array_2_ctor (Value Value) ValueArray2)
(extern constructor value_array_2_ctor value_array_2_ctor)
(decl value_array_3_ctor (Value Value Value) ValueArray3)
(extern constructor value_array_3_ctor value_array_3_ctor)
(decl value_list_slice (ValueSlice) ValueList)
(extern extractor infallible value_list_slice value_list_slice)
(decl value_slice_unwrap (Value ValueSlice) ValueSlice)
(extern extractor value_slice_unwrap value_slice_unwrap)
(decl unwrap_head_value_list_1 (Value ValueSlice) ValueList)
(extractor (unwrap_head_value_list_1 head tail)
           (value_list_slice (value_slice_unwrap head tail)))

(decl pure first_result (Inst) Value)
(extern constructor first_result first_result)
(convert Inst Value first_result)

(decl has_type (Type Inst) Inst)
(extractor (has_type ty inst) (and (result_type ty) inst))
(decl result_type (Type) Inst)
(extern extractor result_type result_type)

(decl cursor_position_at (Inst) CursorPosition)
(extern constructor cursor_position_at cursor_position_at)
(convert Inst CursorPosition cursor_position_at)

;; Returns the position of the cursor just before the current instruction was
;; being legalized. This can be used to re-legalize the sequence of instructions
;; used to replace another instruction.
(decl prev_position () CursorPosition)
(extern constructor prev_position prev_position)

(decl pointer_type () Type)
(extern constructor pointer_type pointer_type)

;; Helper to generate an `iconst` value which has type `I64` and the provided
;; value.
(decl ins_i64 (i64) Value)
(rule (ins_i64 val) (ins_iconst $I64 (imm64 (i64_as_u64 val))))

;; Optionally "legalize" an instruction by replacing the current instruction or
;; inserting new instructions/blocks.
;;
;; This is used to transform CLIF into something which can be handled by each
;; individual backend. There is both common functionality of legalization for
;; all backends in addition to backend-specific legalization.
;;
;; Note that this function is defined here and while some legalizations are
;; performed in this file there are also backend-specific legalizations
;; throughout each backend as well.
;;
;; The return value of this function is where to resume legalization. By default
;; this is the current instruction which means that legalization will continue
;; after the current instruction. If the inserted code itself needs to be
;; re-legalized then the `(prev_position)` constructor can be used to rerun
;; over the sequence of replaced instructions.
(decl partial legalize (Inst) CursorPosition)

;; ========= `{u,s}extend` ====================================================

;; Helper to replace a `uextend` to i128 with an `iconcat` instruction instead.
(decl replace_uextend_i128 (Value) Inst)
(rule 0 (replace_uextend_i128 x @ (value_type (fits_in_32 _)))
  (replace_iconcat $I64 (ins_uextend $I64 x) (ins_i64 0)))
(rule 1 (replace_uextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_i64 0)))

;; Helper to replace a `sextend` to i128 with an `iconcat` instruction instead.
(decl replace_sextend_i128 (Value) Inst)
(rule 0 (replace_sextend_i128 x @ (value_type (fits_in_32 _)))
  (let ((val64 Value (ins_sextend $I64 x)))
    (replace_iconcat $I64 val64 (ins_sshr $I64 val64 (ins_i64 63)))))
(rule 1 (replace_sextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_sshr $I64 x (ins_i64 63))))

;; ========= `{dynamic_,}stack_{load,store}` ==================================

;; stack_load(slot, offset) => load(stack_addr(slot, offset), 0)
(rule (legalize (has_type ty (stack_load slot offset)))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; stack_store(val, slot, offset) => store(val, stack_addr(slot, offset), 0)
(rule (legalize (stack_store val @ (value_type ty) slot offset))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))

;; dynamic_stack_load(slot) => load(dynamic_stack_addr(slot), 0)
(rule (legalize (has_type ty (dynamic_stack_load slot)))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; dynamic_stack_store(val, slot) => store(val, dynamic_stack_addr(slot), 0)
(rule (legalize (dynamic_stack_store val @ (value_type ty) slot))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))

;; ========= `trapz`, `trapnz`, `resumable_trapnz` ============================

;; Delegate back to Rust to perform the basic-block manipulation necessary to
;; expand these instructions

(rule (legalize (trapz val code)) (expand_trapz val code))
(decl expand_trapz (Value TrapCode) CursorPosition)
(extern constructor expand_trapz expand_trapz)

(rule (legalize (trapnz val code)) (expand_trapnz val code))
(decl expand_trapnz (Value TrapCode) CursorPosition)
(extern constructor expand_trapnz expand_trapnz)

(rule (legalize (resumable_trapnz val code)) (expand_resumable_trapnz val code))
(decl expand_resumable_trapnz (Value TrapCode) CursorPosition)
(extern constructor expand_resumable_trapnz expand_resumable_trapnz)

;; ========= `*_imm` instrs ===================================================

(rule (legalize (has_type ty (band_imm val imm)))
  (replace_band ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (bor_imm val imm)))
  (replace_bor ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (bxor_imm val imm)))
  (replace_bxor ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (ishl_imm val imm)))
  (replace_ishl ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (sshr_imm val imm)))
  (replace_sshr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (ushr_imm val imm)))
  (replace_ushr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (rotl_imm val imm)))
  (replace_rotl ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (rotr_imm val imm)))
  (replace_rotr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (iadd_imm val imm)))
  (replace_iadd ty val (ins_signed_const (lane_type ty) imm)))

;; note the reversed arguments in the `isub`
(rule (legalize (has_type ty (irsub_imm val imm)))
  (replace_isub ty (ins_signed_const (lane_type ty) imm) val))

(rule (legalize (has_type ty (imul_imm val imm)))
  (replace_imul ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (sdiv_imm val imm)))
  (replace_sdiv ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (srem_imm val imm)))
  (replace_srem ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (udiv_imm val imm)))
  (replace_udiv ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (urem_imm val imm)))
  (replace_urem ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (icmp_imm cc val @ (value_type ty) imm))
  (replace_icmp ty cc val (ins_signed_const (lane_type ty) imm)))

(decl ins_unsigned_const (Type Imm64) Value)
(rule (ins_unsigned_const $I8 (u64_from_imm64 n))
  (ins_iconst $I8 (imm64 (u64_and n 0xff))))
(rule (ins_unsigned_const $I16 (u64_from_imm64 n))
  (ins_iconst $I16 (imm64 (u64_and n 0xffff))))
(rule (ins_unsigned_const $I32 (u64_from_imm64 n))
  (ins_iconst $I32 (imm64 (u64_and n 0xffffffff))))
(rule (ins_unsigned_const $I64 imm)
  (ins_iconst $I64 imm))
(rule (ins_unsigned_const $I128 imm)
  (ins_iconcat $I64 (ins_iconst $I64 imm) (ins_i64 0)))

(decl ins_signed_const (Type Imm64) Value)
(rule 0 (ins_signed_const (fits_in_64 ty) imm)
  (ins_unsigned_const ty imm))
(rule 1 (ins_signed_const $I128 imm)
  (ins_iconcat $I64
    (ins_iconst $I64 imm)
    (ins_iconst $I64 (imm64_sshr $I64 imm (imm64 63)))))

;; ========= `*_not` instrs ===================================================

;; Legalize the fused bitwise-plus-not instructions into simpler
;; instructions to assist with optimizations. Lowering will
;; pattern match this sequence regardless when architectures
;; support the instruction natively.

(rule (legalize (has_type ty (band_not a b)))
  (replace_band ty a (ins_bnot ty b)))

(rule (legalize (has_type ty (bor_not a b)))
  (replace_bor ty a (ins_bnot ty b)))

(rule (legalize (has_type ty (bxor_not a b)))
  (replace_bxor ty a (ins_bnot ty b)))

;; ========= `global_value` ===================================================

(rule (legalize (global_value gv @ (gv_vmcontext)))
  (replace_vmctx_addr gv))
(decl replace_vmctx_addr (GlobalValue) CursorPosition)
(extern constructor replace_vmctx_addr replace_vmctx_addr)

(rule (legalize (global_value (gv_load base offset ty flags)))
  (let ((base Value (ins_global_value_copy_facts (pointer_type) base))
        (_ Inst (replace_load ty flags base offset)))
    ;; re-legalize the previous instrs to legalize the new `global_value` node
    (prev_position)))

(rule (legalize (global_value (gv_iadd_imm gv_base offset ty)))
  (let ((base Value (ins_global_value_copy_facts ty gv_base))
        (offset Value (ins_iconst_with_fact ty offset gv_base))
        (_ Inst (replace_iadd ty base offset)))
    ;; re-legalize the previous instrs to legalize the new `global_value` node
    (prev_position)))

(rule (legalize (global_value (gv_const_vector_scale ty)))
  (replace_iconst (pointer_type) (imm64 (const_vector_scale ty))))
(decl const_vector_scale (Type) u64)
(extern constructor const_vector_scale const_vector_scale)

(rule (legalize (global_value gv @ (gv_symbol _ _)))
  (replace_symbol_value (pointer_type) gv))

(rule (legalize (global_value gv @ (gv_tls_symbol _ _)))
  (replace_tls_value (pointer_type) gv))

(type GlobalValueData extern (enum
  (VMContext)
  (Load
    (base GlobalValue)
    (offset Offset32)
    (global_type Type)
    (flags MemFlags))
  (IAddImm
    (base GlobalValue)
    (offset Imm64)
    (global_type Type))
  (Symbol
    (name ExternalName)
    (offset Imm64)
    (colocated bool)
    (tls bool))
  (DynScaleTargetConst
    (vector_type Type))
))

;; Convert from `GlobalValue` to `GlobalValueData`
(decl gv_data (GlobalValueData) GlobalValue)
(extern extractor infallible gv_data gv_data)

;; Helper extractors for each variant of `GlobalValue`
(decl gv_vmcontext () GlobalValue)
(extractor (gv_vmcontext)
  (gv_data (GlobalValueData.VMContext)))
(decl gv_load (GlobalValue Offset32 Type MemFlags) GlobalValue)
(extractor (gv_load base offset ty flags)
  (gv_data (GlobalValueData.Load base offset ty flags)))
(decl gv_iadd_imm (GlobalValue Offset32 Type) GlobalValue)
(extractor (gv_iadd_imm base offset ty)
  (gv_data (GlobalValueData.IAddImm base offset ty)))
(decl gv_symbol (Imm64 bool) GlobalValue)
(extractor (gv_symbol offset colocated)
  (gv_data (GlobalValueData.Symbol _ offset colocated $false)))
(decl gv_tls_symbol (Imm64 bool) GlobalValue)
(extractor (gv_tls_symbol offset colocated)
  (gv_data (GlobalValueData.Symbol _ offset colocated $true)))
(decl gv_const_vector_scale (Type) GlobalValue)
(extractor (gv_const_vector_scale ty)
  (gv_data (GlobalValueData.DynScaleTargetConst ty)))

;; This is the dual of the `ins_global_value` constructor except that this one
;; additionally copies PCC facts from the `GlobalValue` onto the returned
;; `Inst`.
(decl ins_global_value_copy_facts (Type GlobalValue) Inst)
(rule (ins_global_value_copy_facts ty gv)
  (let ((ret Inst (ins_global_value ty gv))
        (_ Unit (update_inst_facts_with_gv gv ret)))
    ret))
(decl ins_iconst_with_fact (Type Imm64 GlobalValue) Inst)
(rule (ins_iconst_with_fact ty imm gv)
  (let ((ret Inst (ins_iconst ty imm))
        (_ Unit (update_const_facts ty imm gv ret)))
    ret))
(decl update_inst_facts_with_gv (GlobalValue Value) Unit)
(extern constructor update_inst_facts_with_gv update_inst_facts_with_gv)
(decl update_const_facts (Type Imm64 GlobalValue Value) Unit)
(extern constructor update_const_facts update_const_facts)

;; ========= `table_addr` =====================================================

(rule (legalize (has_type addr_ty (table_addr table idx @ (value_type idx_ty) offset)))
  (let (
    ;; Start with the bounds check. Trap if `index + 1 > bound`.
    ;; `index > bound - 1` is the same as `index >= bound`.
    (bound Inst (ins_global_value_copy_facts idx_ty (table_bound_gv table)))
    (cmp Inst (ins_icmp $I8 (IntCC.UnsignedGreaterThanOrEqual) idx bound))
    (_ Inst (ins_trapnz $I8 cmp (TrapCode.TableOutOfBounds)))

    ;; Calculate the offset, in bytes, by multiplying `idx` by the byte size
    ;; of the table element.
    (idx Value (extend_index_to_addr idx addr_ty))
    (idx_offset Value (ins_imul_imm addr_ty idx (imm64 (table_element_size table))))

    ;; Calculate the final address by adding the table base address to the
    ;; element offset to the static offset in the `table_addr` instruction.
    (base Value (ins_global_value_copy_facts addr_ty (table_base_gv table)))
    (offset Value (ins_iconst addr_ty (imm64 (i64_as_u64 (offset32_to_i32 offset)))))
    (elem_addr Value (ins_iadd addr_ty (ins_iadd addr_ty base idx_offset) offset))

    ;; Generate the final `result` and replace the current instruction with that.
    (result Value (select_table_addr cmp base elem_addr))
    (_ Inst (replace_with_aliases result))
  )
  ;; re-legalize the above instructions
  (prev_position)))

(decl select_table_addr (Value Value Value) Value)
(rule (select_table_addr cmp base @ (value_type ty) element_addr)
  (if-let $true (enable_table_access_spectre_mitigation))
  (ins_select_spectre_guard ty cmp base element_addr))
(rule (select_table_addr cmp base @ (value_type ty) element_addr)
  (if-let $false (enable_table_access_spectre_mitigation))
  element_addr)

(decl extend_index_to_addr (Value Type) Value)
(rule 0 (extend_index_to_addr val ty) (ins_uextend ty val))
(rule 1 (extend_index_to_addr val @ (value_type ty) ty) val)

(decl table_bound_gv (Table) GlobalValue)
(extern constructor table_bound_gv table_bound_gv)
(decl table_base_gv (Table) GlobalValue)
(extern constructor table_base_gv table_base_gv)
(decl table_element_size (Table) u64)
(extern constructor table_element_size table_element_size)
(decl pure enable_table_access_spectre_mitigation () bool)
(extern constructor enable_table_access_spectre_mitigation enable_table_access_spectre_mitigation)

(decl replace_with_aliases (Value) Inst)
(extern constructor replace_with_aliases replace_with_aliases)

;; ========= NaN canonicalization =============================================

(rule (legalize (has_type ty (ceil val)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_ceil ty val)))

(rule (legalize (has_type ty (floor val)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_floor ty val)))

(rule (legalize (has_type ty (nearest val)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_nearest ty val)))

(rule (legalize (has_type ty (trunc val)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_trunc ty val)))

(rule (legalize (has_type ty (sqrt val)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_sqrt ty val)))

(rule (legalize (has_type ty (fadd a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fadd ty a b)))

(rule (legalize (has_type ty (fsub a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fsub ty a b)))

(rule (legalize (has_type ty (fmul a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fmul ty a b)))

(rule (legalize (has_type ty (fdiv a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fdiv ty a b)))

(rule (legalize (has_type ty (fmin a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fmin ty a b)))

(rule (legalize (has_type ty (fmax a b)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fmax ty a b)))

(rule (legalize (has_type ty (fma a b c)))
  (if-let $true (enable_nan_canonicalization))
  (replace_canonicalized ty (ins_fma ty a b c)))

(decl replace_canonicalized (Type Value) Inst)
(rule (replace_canonicalized $F32 val)
  (replace_select $F32 (ins_fcmp $I8 (FloatCC.NotEqual) val val) (canon_nan32) val))
(rule (replace_canonicalized $F64 val)
  (replace_select $F64 (ins_fcmp $I8 (FloatCC.NotEqual) val val) (canon_nan64) val))
(rule (replace_canonicalized $F32X4 val)
  (let ((cmp Value (ins_fcmp $I32X4 (FloatCC.NotEqual) val val))
        (canon Value (ins_splat $F32X4 (canon_nan32)))
        (mask Value (ins_bitcast $F32X4 (mem_flags_empty) cmp)))
    (replace_bitselect $F32X4 mask canon val)))
(rule (replace_canonicalized $F64X2 val)
  (let ((canon Value (ins_splat $F64X2 (canon_nan64)))
        (cmp Value (ins_fcmp $I64X2 (FloatCC.NotEqual) val val))
        (mask Value (ins_bitcast $F64X2 (mem_flags_empty) cmp)))
    (replace_bitselect $F64X2 mask canon val)))

(decl pure enable_nan_canonicalization () bool)
(extern constructor enable_nan_canonicalization enable_nan_canonicalization)

(decl canon_nan32 () Value)
(extern constructor canon_nan32 canon_nan32)

(decl canon_nan64 () Value)
(extern constructor canon_nan64 canon_nan64)
