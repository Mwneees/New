;; Legalizing CLIF to CLIF
;;
;; This file is one of the main entry points for performing "legalizations" that
;; transform CLIF to CLIF to simplify the IR for one phase or another. One
;; example of a legalization is replacing "macro instructions" with their
;; components, such as the `stack_store` CLIF instruction with a `stack_addr`
;; plus a `store`. This way backends don't need to implement lowering for
;; all three instructions, only the latter two.
;;
;; Backends also have their own forms of legalization as well. For example
;; instead of natively implementing a `uextend`-to-128-bits backends can choose
;; to legalize the `uextend` instruction in this case to be replaced with an
;; `iconcat`. This can help reduce the number of lowerings that a backend needs
;; while sharing legalization code with other backends.
;;
;; This file is organized as shared support for all backends. This contains
;; the definition of the `legalize` function which is the main entrypoint for
;; transforming instructions. Some required legalizations are defined in this
;; file such as legalizing the CLIF `stack_store` pseudo-instruction. Otherwise
;; platform-neutral helpers are defined in this file that each backend can
;; opt-in to as desired.

;; ========= Type Definitions =================================================

(type Inst (primitive Inst))

;; ========= Helper extractors/constructors ===================================

;; Helper used in generated extractors for each CLIF instruction to extract
;; information from an `Inst`.
(decl inst_data (InstructionData) Inst)
(extern extractor infallible inst_data inst_data)

;; Helper used to perform an `ins()` operation which inserts just before the
;; current instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `ins_*` prefix.
(decl ins (Type InstructionData) Inst)
(extern constructor ins ins)

;; Helper used to perform a `replace()` operation which replaces the current
;; instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `replace_*` prefix.
(decl replace (Type InstructionData) Inst)
(extern constructor replace replace)

;; Constructors for value arrays.
(decl value_array_2_ctor (Value Value) ValueArray2)
(extern constructor value_array_2_ctor value_array_2_ctor)
(decl value_array_3_ctor (Value Value Value) ValueArray3)
(extern constructor value_array_3_ctor value_array_3_ctor)
(decl value_list_slice (ValueSlice) ValueList)
(extern extractor infallible value_list_slice value_list_slice)
(decl value_slice_unwrap (Value ValueSlice) ValueSlice)
(extern extractor value_slice_unwrap value_slice_unwrap)
(decl unwrap_head_value_list_1 (Value ValueSlice) ValueList)
(extractor (unwrap_head_value_list_1 head tail)
           (value_list_slice (value_slice_unwrap head tail)))

(decl pure first_result (Inst) Value)
(extern constructor first_result first_result)
(convert Inst Value first_result)

(decl has_type (Type Inst) Inst)
(extractor (has_type ty inst) (and (result_type ty) inst))
(decl result_type (Type) Inst)
(extern extractor result_type result_type)

;; Helper to generate an `iconst` value which has type `I64` and the provided
;; value.
(decl ins_i64 (i64) Value)
(rule (ins_i64 val) (ins_iconst $I64 (imm64 (i64_as_u64 val))))

;; Optionally "legalize" an instruction to a new instruction.
;;
;; This is used to transform CLIF into something which can be handled by each
;; individual backend. There is both common functionality of legalization for
;; all backends in addition to backend-specific legalization.
;;
;; Note that this function is defined here and while some legalizations are
;; performed in this file there are also backend-specific legalizations
;; throughout each backend as well.
(decl partial legalize (Inst) Inst)

;; ========= `{u,s}extend` ====================================================

;; Helper to replace a `uextend` to i128 with an `iconcat` instruction instead.
(decl replace_uextend_i128 (Value) Inst)
(rule 0 (replace_uextend_i128 x @ (value_type (fits_in_32 _)))
  (replace_iconcat $I64 (ins_uextend $I64 x) (ins_i64 0)))
(rule 1 (replace_uextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_i64 0)))

;; Helper to replace a `sextend` to i128 with an `iconcat` instruction instead.
(decl replace_sextend_i128 (Value) Inst)
(rule 0 (replace_sextend_i128 x @ (value_type (fits_in_32 _)))
  (let ((val64 Value (ins_sextend $I64 x)))
    (replace_iconcat $I64 val64 (ins_sshr $I64 val64 (ins_i64 63)))))
(rule 1 (replace_sextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_sshr $I64 x (ins_i64 63))))

;; ========= `{dynamic_,}stack_{load,store}` ==================================

;; stack_load(slot, offset) => load(stack_addr(slot, offset), 0)
(rule (legalize (has_type ty (stack_load slot offset)))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; stack_store(val, slot, offset) => store(val, stack_addr(slot, offset), 0)
(rule (legalize (stack_store val @ (value_type ty) slot offset))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))

;; dynamic_stack_load(slot) => load(dynamic_stack_addr(slot), 0)
(rule (legalize (has_type ty (dynamic_stack_load slot)))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; dynamic_stack_store(val, slot) => store(val, dynamic_stack_addr(slot), 0)
(rule (legalize (dynamic_stack_store val @ (value_type ty) slot))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))

;; ========= `trapz`, `trapnz`, `resumable_trapnz` ============================

;; Delegate back to Rust to perform the basic-block manipulation necessary to
;; expand these instructions

(rule (legalize (trapz val code)) (expand_trapz val code))
(decl expand_trapz (Value TrapCode) Inst)
(extern constructor expand_trapz expand_trapz)

(rule (legalize (trapnz val code)) (expand_trapnz val code))
(decl expand_trapnz (Value TrapCode) Inst)
(extern constructor expand_trapnz expand_trapnz)

(rule (legalize (resumable_trapnz val code)) (expand_resumable_trapnz val code))
(decl expand_resumable_trapnz (Value TrapCode) Inst)
(extern constructor expand_resumable_trapnz expand_resumable_trapnz)

;; ========= `*_imm` instrs ===================================================

(rule (legalize (has_type ty (band_imm val imm)))
  (replace_band ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (bor_imm val imm)))
  (replace_bor ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (bxor_imm val imm)))
  (replace_bxor ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (ishl_imm val imm)))
  (replace_ishl ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (sshr_imm val imm)))
  (replace_sshr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (ushr_imm val imm)))
  (replace_ushr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (rotl_imm val imm)))
  (replace_rotl ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (rotr_imm val imm)))
  (replace_rotr ty val (ins_unsigned_const (lane_type ty) imm)))

(rule (legalize (has_type ty (iadd_imm val imm)))
  (replace_iadd ty val (ins_signed_const (lane_type ty) imm)))

;; note the reversed arguments in the `isub`
(rule (legalize (has_type ty (irsub_imm val imm)))
  (replace_isub ty (ins_signed_const (lane_type ty) imm) val))

(rule (legalize (has_type ty (imul_imm val imm)))
  (replace_imul ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (sdiv_imm val imm)))
  (replace_sdiv ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (srem_imm val imm)))
  (replace_srem ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (udiv_imm val imm)))
  (replace_udiv ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (has_type ty (urem_imm val imm)))
  (replace_urem ty val (ins_signed_const (lane_type ty) imm)))

(rule (legalize (icmp_imm cc val @ (value_type ty) imm))
  (replace_icmp ty cc val (ins_signed_const (lane_type ty) imm)))

(decl ins_unsigned_const (Type Imm64) Value)
(rule (ins_unsigned_const $I8 (u64_from_imm64 n))
  (ins_iconst $I8 (imm64 (u64_and n 0xff))))
(rule (ins_unsigned_const $I16 (u64_from_imm64 n))
  (ins_iconst $I16 (imm64 (u64_and n 0xffff))))
(rule (ins_unsigned_const $I32 (u64_from_imm64 n))
  (ins_iconst $I32 (imm64 (u64_and n 0xffffffff))))
(rule (ins_unsigned_const $I64 imm)
  (ins_iconst $I64 imm))
(rule (ins_unsigned_const $I128 imm)
  (ins_iconcat $I64 (ins_iconst $I64 imm) (ins_i64 0)))

(decl ins_signed_const (Type Imm64) Value)
(rule 0 (ins_signed_const (fits_in_64 ty) imm)
  (ins_unsigned_const ty imm))
(rule 1 (ins_signed_const $I128 imm)
  (ins_iconcat $I64
    (ins_iconst $I64 imm)
    (ins_iconst $I64 (imm64_sshr $I64 imm (imm64 63)))))

;; ========= `*_not` instrs ===================================================

;; Legalize the fused bitwise-plus-not instructions into simpler
;; instructions to assist with optimizations. Lowering will
;; pattern match this sequence regardless when architectures
;; support the instruction natively.

(rule (legalize (has_type ty (band_not a b)))
  (replace_band ty a (ins_bnot ty b)))

(rule (legalize (has_type ty (bor_not a b)))
  (replace_bor ty a (ins_bnot ty b)))

(rule (legalize (has_type ty (bxor_not a b)))
  (replace_bxor ty a (ins_bnot ty b)))
