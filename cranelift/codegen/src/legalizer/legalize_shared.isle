;; Legalizing CLIF to CLIF
;;
;; This file is one of the main entry points for performing "legalizations" that
;; transform CLIF to CLIF to simplify the IR for one phase or another. One
;; example of a legalization is replacing "macro instructions" with their
;; components, such as the `stack_store` CLIF instruction with a `stack_addr`
;; plus a `store`. This way backends don't need to implement lowering for
;; all three instructions, only the latter two.
;;
;; Backends also have their own forms of legalization as well. For example
;; instead of natively implementing a `uextend`-to-128-bits backends can choose
;; to legalize the `uextend` instruction in this case to be replaced with an
;; `iconcat`. This can help reduce the number of lowerings that a backend needs
;; while sharing legalization code with other backends.
;;
;; This file is organized as shared support for all backends. This contains
;; the definition of the `legalize` function which is the main entrypoint for
;; transforming instructions. Some required legalizations are defined in this
;; file such as legalizing the CLIF `stack_store` pseudo-instruction. Otherwise
;; platform-neutral helpers are defined in this file that each backend can
;; opt-in to as desired.

;; ========= Type Definitions =================================================

(type Inst (primitive Inst))

;; ========= Helper extractors/constructors ===================================

;; Helper used in generated extractors for each CLIF instruction to extract
;; information from an `Inst`.
(decl inst_data (InstructionData) Inst)
(extern extractor infallible inst_data inst_data)

;; Helper used to perform an `ins()` operation which inserts just before the
;; current instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `ins_*` prefix.
(decl ins (Type InstructionData) Inst)
(extern constructor ins ins)

;; Helper used to perform a `replace()` operation which replaces the current
;; instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `replace_*` prefix.
(decl replace (Type InstructionData) Inst)
(extern constructor replace replace)

;; Constructors for value arrays.
(decl value_array_2_ctor (Value Value) ValueArray2)
(extern constructor value_array_2_ctor value_array_2_ctor)
(decl value_array_3_ctor (Value Value Value) ValueArray3)
(extern constructor value_array_3_ctor value_array_3_ctor)
(decl value_list_slice (ValueSlice) ValueList)
(extern extractor infallible value_list_slice value_list_slice)
(decl value_slice_unwrap (Value ValueSlice) ValueSlice)
(extern extractor value_slice_unwrap value_slice_unwrap)
(decl unwrap_head_value_list_1 (Value ValueSlice) ValueList)
(extractor (unwrap_head_value_list_1 head tail)
           (value_list_slice (value_slice_unwrap head tail)))

(decl pure first_result (Inst) Value)
(extern constructor first_result first_result)
(convert Inst Value first_result)

(decl has_type (Type Inst) Inst)
(extractor (has_type ty inst) (and (result_type ty) inst))
(decl result_type (Type) Inst)
(extern extractor result_type result_type)

;; Helper to generate an `iconst` value which has type `I64` and the provided
;; value.
(decl ins_i64 (i64) Value)
(rule (ins_i64 val) (ins_iconst $I64 (imm64 (i64_as_u64 val))))

;; Optionally "legalize" an instruction to a new instruction.
;;
;; This is used to transform CLIF into something which can be handled by each
;; individual backend. There is both common functionality of legalization for
;; all backends in addition to backend-specific legalization.
;;
;; Note that this function is defined here and while some legalizations are
;; performed in this file there are also backend-specific legalizations
;; throughout each backend as well.
(decl partial legalize (Inst) Inst)

;; ========= `{u,s}extend` ====================================================

;; Helper to replace a `uextend` to i128 with an `iconcat` instruction instead.
(decl replace_uextend_i128 (Value) Inst)
(rule 0 (replace_uextend_i128 x @ (value_type (fits_in_32 _)))
  (replace_iconcat $I64 (ins_uextend $I64 x) (ins_i64 0)))
(rule 1 (replace_uextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_i64 0)))

;; Helper to replace a `sextend` to i128 with an `iconcat` instruction instead.
(decl replace_sextend_i128 (Value) Inst)
(rule 0 (replace_sextend_i128 x @ (value_type (fits_in_32 _)))
  (let ((val64 Value (ins_sextend $I64 x)))
    (replace_iconcat $I64 val64 (ins_sshr $I64 val64 (ins_i64 63)))))
(rule 1 (replace_sextend_i128 x @ (value_type $I64))
  (replace_iconcat $I64 x (ins_sshr $I64 x (ins_i64 63))))

;; ========= `{dynamic_,}stack_{load,store}` ==================================

;; stack_load(slot, offset) => load(stack_addr(slot, offset), 0)
(rule (legalize (has_type ty (stack_load slot offset)))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; stack_store(val, slot, offset) => store(val, stack_addr(slot, offset), 0)
(rule (legalize (stack_store val @ (value_type ty) slot offset))
  (let ((addr Value (ins_stack_addr $I64 slot offset)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))

;; dynamic_stack_load(slot) => load(dynamic_stack_addr(slot), 0)
(rule (legalize (has_type ty (dynamic_stack_load slot)))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_load ty (mem_flags_notrap) addr (i32_to_offset32 0))))

;; dynamic_stack_store(val, slot) => store(val, dynamic_stack_addr(slot), 0)
(rule (legalize (dynamic_stack_store val @ (value_type ty) slot))
  (let ((addr Value (ins_dynamic_stack_addr $I64 slot)))
    (replace_store ty (mem_flags_notrap) val addr (i32_to_offset32 0))))
