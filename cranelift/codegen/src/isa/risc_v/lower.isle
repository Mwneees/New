;; risc_v instruction selection and CLIF-to-MachInst lowering.

;; The main lowering constructor term: takes a clif `Inst` and returns the
;; register(s) within which the lowered instruction's result values live.
(decl lower (Inst) InstOutput)

;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (iconst (u64_from_imm64 n))))
      (imm ty n))

;;;; Rules for `bconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (bconst $false)))
      (imm ty 0))

(rule (lower (has_type ty (bconst $true)))
      (imm ty 1))


;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (null)))
      (imm ty 0))


;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller

(rule (lower (has_type (fits_in_32 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.ADDW) x y))

;; Base case, simply adding things in registers.
(rule (lower (has_type (fits_in_64 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.ADD) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (iadd x (imm12_from_value y))))
      (alu_rr_imm12 (select_addi ty) x y))

(rule (lower (has_type (fits_in_64 ty) (iadd (imm12_from_value x) y)))
      (alu_rr_imm12 (select_addi ty) y x))


;; i128




;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Base case, simply subtracting things in registers.

(rule (lower (has_type (fits_in_64 ty) (isub x y)))
      (alu_rrr (AluOPRRR.SUB) x y))
(rule (lower (has_type (fits_in_32 ty) (isub x y)))
      (alu_rrr (AluOPRRR.SUBW) x y))
      
;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub x (imm12_from_value y))))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub (imm12_from_value y) x)))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))


;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller.
(rule (lower (has_type (fits_in_64 ty) (ineg x)))
      (alu_rrr (AluOPRRR.SUB) (zero_reg) x))
(rule (lower (has_type (fits_in_32 ty) (ineg x)))
      (alu_rrr (AluOPRRR.SUBW) (zero_reg) x))


;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_64 ty) (imul x y)))
      (alu_rrr (AluOPRRR.MUL) x y))
(rule (lower (has_type (fits_in_32 ty) (imul x y)))
      (alu_rrr (AluOPRRR.MULW) x y))

(rule (lower (has_type (fits_in_64 ty) (smulhi x y)))
      (alu_rrr (AluOPRRR.MULH) x y))

(rule (lower (has_type (fits_in_64 ty) (umulhi x y)))
      (alu_rrr (AluOPRRR.MULHSU) x y))


;;;; Rules for `div` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.DIVW) x y))

(rule (lower (has_type (fits_in_32 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.DIVUW) x y))

(rule (lower (has_type (fits_in_64 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.DIV) x y))

(rule (lower (has_type (fits_in_64 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.DIVU) x y))


;;;; Rules for `rem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_32 ty) (srem x y)))
      (alu_rrr (AluOPRRR.REMW) x y))

(rule (lower (has_type (fits_in_32 ty) (urem x y)))
      (alu_rrr (AluOPRRR.REMUW) x y))

(rule (lower (has_type (fits_in_64 ty) (srem x y)))
      (alu_rrr (AluOPRRR.REM) x y))

(rule (lower (has_type (fits_in_64 ty) (urem x y)))
      (alu_rrr (AluOPRRR.REMU) x y))

;;;; Rules for `and` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band x y)))
      (alu_rrr (AluOPRRR.AND) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (band x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.ANDI) x y))

(rule (lower (has_type (fits_in_64 ty) (band (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.ANDI) y x))

;;;; Rules for `or` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor x y)))
      (alu_rrr (AluOPRRR.OR) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.ORI) x y))

(rule (lower (has_type (fits_in_64 ty) (bor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.ORI) y x))

;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bxor x y)))
      (alu_rrr (AluOPRRR.XOR) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bxor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.XORI) x y))

(rule (lower (has_type (fits_in_64 ty) (bxor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.XORI) y x))



;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


