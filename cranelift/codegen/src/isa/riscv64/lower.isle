;; riscv64 instruction selection and CLIF-to-MachInst lowering.

;; The main lowering constructor term: takes a clif `Inst` and returns the
;; register(s) within which the lowered instruction's result values live.
(decl lower (Inst) InstOutput)

;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (iconst (u64_from_imm64 n))))
      (imm ty n))

;;;; Rules for `bconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (bconst $false)))
      (imm ty 0))

(rule (lower (has_type ty (bconst $true)))
      (imm ty 1))


;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (null)))
      (imm ty 0))


;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller

(rule (lower (has_type (fits_in_32 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Addw) $I32 x y))

;; Base case, simply adding things in registers.
(rule (lower (has_type (fits_in_64 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Add) $I64 x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (iadd x (imm12_from_value y))))
      (alu_rr_imm12 (select_addi ty) x y))

(rule (lower (has_type (fits_in_64 ty) (iadd (imm12_from_value x) y)))
      (alu_rr_imm12 (select_addi ty) y x))

(rule (lower (has_type $I128 (iadd  x y)))
      (i128_arithmetic (I128OP.Add) x y))

;; i128


;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Base case, simply subtracting things in registers.

(rule (lower (has_type (fits_in_64 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Sub) $I64 x y))

(rule (lower (has_type (fits_in_32 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Subw) $I32 x y))
      
;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub x (imm12_from_value y))))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub (imm12_from_value y) x)))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

(rule (lower (has_type $I128 (isub x y)))
      (i128_arithmetic (I128OP.Sub) x y))



;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller.
(rule (lower (has_type (fits_in_64 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Sub) $I64 (zero_reg) x))
(rule (lower (has_type (fits_in_32 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Subw) $I32 (zero_reg) x))


;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_64 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mul) $I64 x y))
(rule (lower (has_type (fits_in_32 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mulw) $I32 x y))

(rule (lower (has_type (fits_in_64 ty) (smulhi x y)))
      (lower_mlhi $true ty x y))

(rule (lower (has_type (fits_in_64 ty) (umulhi x y)))
      (lower_mlhi $false ty x y))

(rule (lower (has_type $I128 (imul x y)))
      (i128_arithmetic (I128OP.Mul) x y))


;;;; Rules for `div` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_16 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.Divuw) $I64 (narrow_int ty x) (narrow_int ty y)))

(rule (lower (has_type (fits_in_32 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Divw) $I64 x y))

(rule (lower (has_type (fits_in_32 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.Divuw) $I64  x y))

(rule (lower (has_type (fits_in_64 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Div) $I64 x y))

(rule (lower (has_type (fits_in_64 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.DivU) $I64 x y))

;;;; Rules for `rem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_32 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Remw) $I64 x y))

(rule (lower (has_type (fits_in_16 ty) (urem x y)))
      (alu_rrr (AluOPRRR.Remuw) $I64 (narrow_int ty x) (narrow_int ty y)))

(rule (lower (has_type (fits_in_32 ty) (urem x y)))
      (alu_rrr (AluOPRRR.Remuw) $I64 x y))

(rule (lower (has_type (fits_in_64 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Rem) $I64  x y))

(rule (lower (has_type (fits_in_64 ty) (urem x y)))
      (alu_rrr (AluOPRRR.RemU) $I64 x y))

;;;; Rules for `and` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band x y)))
      (alu_rrr (AluOPRRR.And) $I64 x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (band x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Andi) x y))

(rule (lower (has_type (fits_in_64 ty) (band (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Andi) y x))

(rule (lower (has_type $B128 (band x y)))
      (lower_b128_binary (AluOPRRR.And) x y))
(rule (lower (has_type $I128 (band x y)))
      (lower_b128_binary (AluOPRRR.And) x y))


;;;; Rules for `or` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor x y)))
      (alu_rrr (AluOPRRR.Or) $I64 x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Ori) x y))

(rule (lower (has_type (fits_in_64 ty) (bor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Ori) y x))
(rule (lower (has_type $B128 (bor x y)))
      (lower_b128_binary (AluOPRRR.Or) x y))
(rule (lower (has_type $I128 (bor x y)))
      (lower_b128_binary (AluOPRRR.Or) x y))

;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bxor x y)))
      (alu_rrr (AluOPRRR.Xor) $I64 x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bxor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Xori) x y))

(rule (lower (has_type (fits_in_64 ty) (bxor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Xori) y x))
(rule (lower (has_type $B128 (bxor x y)))
      (lower_b128_binary (AluOPRRR.Xor) x y))
(rule (lower (has_type $I128 (bxor x y)))
      (lower_b128_binary (AluOPRRR.Xor) x y))


;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor_not x y)))
      (alu_rrr (AluOPRRR.Orn)  $I64 x y))
(rule (lower (has_type $B128 (bor_not x y)))
      (lower_b128_binary (AluOPRRR.Orn) x y))
(rule (lower (has_type $I128 (bor_not x y)))
      (lower_b128_binary (AluOPRRR.Orn) x y))


;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; Rules for `bnot` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (bnot x)))
      (lower_float_bnot $F32 x))
(rule (lower (has_type $F32 (bnot x)))
      (lower_float_bnot $F64 x))

(rule (lower (has_type fits_in_64 (bnot x)))
      (alu_rr_imm12 (AluOPRRI.Xori) x (imm_from_neg_bits -1)))

(rule (lower (has_type $I128 (bnot x)))
      (bnot_128 x))
(rule (lower (has_type $B128 (bnot x)))
      (bnot_128 x))


;;;; Rules for `bit_reverse` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (bitrev x)))
      (lower_bit_reverse ty x))

(rule (lower (has_type $I128 (bitrev x)))
      (let ((val ValueRegs x)
            (lo_rev Reg (lower_bit_reverse $I64 (value_regs_get val 0)))
            (hi_rev Reg (lower_bit_reverse $I64 (value_regs_get val 1))))
        (value_regs hi_rev lo_rev)))


;;;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (ctz x)))
      (lower_ctz ty x))

;;;; Rules for `clz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (clz x)))
      (lower_clz ty x))

;;;; Rules for `uextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type out (uextend x @ (value_type in))))
      (lower_extend x $false (ty_bits in) (ty_bits out)))

;;;; Rules for `sextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type out (sextend x @ (value_type in))))
      (lower_extend x $true (ty_bits in) (ty_bits out)))


;;;; Rules for `band_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band_not x y)))
      (alu_rrr (AluOPRRR.Andn) $I64 x y))

(rule (lower (has_type  $I128 (band_not x y)))
      (lower_band_not_i128 x y))

;;;; Rules for `popcnt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_16 ty) (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpopw) (narrow_int ty x) 0))
(rule (lower (has_type $I32 (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpopw) x 0))
(rule (lower (has_type $I64 (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpop) x 0))
(rule (lower (has_type $I128 (popcnt x)))
      (lower_popcnt_i128 x))

;;;; Rules for `ishl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(ishl x (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Sllw) $I64 x y))
(rule (lower (has_type (fits_in_32 ty)(ishl x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Slliw) x y))
(rule (lower (has_type (fits_in_64 ty)(ishl x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Slli) x y))
(rule (lower (has_type (fits_in_64 ty)(ishl x (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Sll) $I64 x y))

(rule (lower (has_type  $I128 (ishl x y)))
      (lower_i128_logical_shift $true $true x y))


;;;; Rules for `ushr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(ushr x  (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Srlw) $I64 x y))
(rule (lower (has_type (fits_in_64 ty)(ushr x (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Srl) $I64 x y))
(rule (lower (has_type (fits_in_32 ty)(ushr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.SrliW) x y))
(rule (lower (has_type (fits_in_64 ty)(ushr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Srli) x y))
(rule (lower (has_type  $I128 (ushr x y)))
      (lower_i128_logical_shift $false $false x y))


;;;; Rules for `sshr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(sshr x (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Sraw) $I64 x y))
(rule (lower (has_type (fits_in_64 ty)(sshr x (valueregs_2_reg y))))
      (alu_rrr (AluOPRRR.Sra) $I64 x y))
(rule (lower (has_type (fits_in_32 ty)(sshr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.SrliW) x y))
(rule (lower (has_type (fits_in_64 ty)(sshr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Srli) x y))
(rule (lower (has_type  $I128 (sshr x y)))
      (lower_i128_logical_shift $false $true x y))


;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(rotl x y)))
      (lower_rotl ty x y))

(rule (lower (has_type  $I128 (rotl x y)))
      (lower_i128_rotate $true x y))

;;;; Rules for `rotr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(rotr x y)))
      (lower_rotr ty x y))

(rule (lower (has_type  $I128 (rotr x y)))
      (lower_i128_rotate $false x y))


;;;; Rules for `bxor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(bxor_not x y)))
      (alu_rrr  (AluOPRRR.Xnor) $I64 y x))  ;; notice x y order!!!

(rule (lower (has_type  $I128 (bxor_not x y)))
      (lower_i128_xnor y x));; notice x y order!!!

(rule (lower (has_type  $F32 (bxor_not x y)))
      (lower_float_xnot $F32 y x))  ;; notice x y order!!!
(rule (lower (has_type  $F64 (bxor_not x y)))
      (lower_float_xnot $F64 y x))  ;; notice x y order!!!


;;;; Rules for `bor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(bor_not x y)))
      (alu_rrr  (AluOPRRR.Orn) $I64 x y))  

(rule (lower (has_type  $I128 (bor_not x y)))
      (lower_b128_binary (AluOPRRR.Orn) x y)) 


;;;; Rules for `cls` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(cls x)))
      (lower_cls  x ty))
(rule (lower (has_type  $I128 (cls x)))
      (lower_cls_i128  x))

 

;;;; Rules for `fabs` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (fabs x)))
      (lower_float_abs $F32 x))
(rule (lower (has_type $F64 (fabs x)))
      (lower_float_abs $F64 x))

;;;; Rules for `fneg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (fneg x)))
      (lower_float_neg $F32 x))
(rule (lower (has_type $F64 (fneg x)))
      (lower_float_neg $F64 x))


;;;; Rules for `fcopysign` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (fcopysign x y)))
      (alu_rrr (AluOPRRR.FsgnjS) $F64 x y))
(rule (lower (has_type $F64 (fcopysign x y)))
      (alu_rrr (AluOPRRR.FsgnjD) $F64 x y))


;;;; Rules for `fma` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (fma  x y z )))
      (alu_rrrr (AluOPRRRR.FmaddS) $F64 x y z))
(rule (lower (has_type $F64 (fma  x y z )))
      (alu_rrrr (AluOPRRRR.FmaddD) $F64 x y z))

;;;; special instruction provides by isa can used to speed up computation.;;;;;;
;;;; Rules for `FmaddS` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (fadd (fmul x y) z )))
      (alu_rrrr (AluOPRRRR.FmaddS) $F64 x y z))

(rule (lower (has_type $F32 (fadd x (fmul y z) )))
      (alu_rrrr (AluOPRRRR.FmaddS) $F64 y z x))

;;;; Rules for `FmaddD` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F64 (fadd (fmul x y) z )))
      (alu_rrrr (AluOPRRRR.FmaddD) $F64 x y z))

(rule (lower (has_type $F64 (fadd x (fmul y z) )))
      (alu_rrrr (AluOPRRRR.FmaddD) $F64 y z x))

;;;; todo support fnmadd.s .......


;;;; Rules for `sqrt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (sqrt x)))
      (alu_rr (AluOPRR.FsqrtS)$F64 x))

(rule (lower (has_type $F64 (sqrt x)))
      (alu_rr (AluOPRR.FsqrtD)$F64 x))