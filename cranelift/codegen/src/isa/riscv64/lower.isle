;; riscv64 instruction selection and CLIF-to-MachInst lowering.

;; The main lowering constructor term: takes a clif `Inst` and returns the
;; register(s) within which the lowered instruction's result values live.
(decl lower (Inst) InstOutput)

;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (iconst (u64_from_imm64 n))))
      (imm ty n))

;;;; Rules for `bconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (bconst $false)))
      (imm ty 0))

(rule (lower (has_type ty (bconst $true)))
      (imm ty 1))


;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (null)))
      (imm ty 0))


;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller

(rule (lower (has_type (fits_in_32 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Addw) x y))

;; Base case, simply adding things in registers.
(rule (lower (has_type (fits_in_64 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Add) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (iadd x (imm12_from_value y))))
      (alu_rr_imm12 (select_addi ty) x y))

(rule (lower (has_type (fits_in_64 ty) (iadd (imm12_from_value x) y)))
      (alu_rr_imm12 (select_addi ty) y x))


;; i128




;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Base case, simply subtracting things in registers.

(rule (lower (has_type (fits_in_64 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Sub) x y))
(rule (lower (has_type (fits_in_32 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Subw) x y))
      
;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub x (imm12_from_value y))))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub (imm12_from_value y) x)))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))


;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller.
(rule (lower (has_type (fits_in_64 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Sub) (zero_reg) x))
(rule (lower (has_type (fits_in_32 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Subw) (zero_reg) x))


;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_64 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mul) x y))
(rule (lower (has_type (fits_in_32 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mulw) x y))

(rule (lower (has_type (fits_in_64 ty) (smulhi x y)))
      (alu_rrr (AluOPRRR.Mulh) x y))

(rule (lower (has_type (fits_in_64 ty) (umulhi x y)))
      (alu_rrr (AluOPRRR.Mulhsu) x y))


;;;; Rules for `div` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Divw) x y))

(rule (lower (has_type (fits_in_32 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.Divuw) x y))

(rule (lower (has_type (fits_in_64 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Div) x y))

(rule (lower (has_type (fits_in_64 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.DivU) x y))


;;;; Rules for `rem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_32 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Remw) x y))

(rule (lower (has_type (fits_in_32 ty) (urem x y)))
      (alu_rrr (AluOPRRR.Remuw) x y))

(rule (lower (has_type (fits_in_64 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Rem) x y))

(rule (lower (has_type (fits_in_64 ty) (urem x y)))
      (alu_rrr (AluOPRRR.RemU) x y))

;;;; Rules for `and` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band x y)))
      (alu_rrr (AluOPRRR.And) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (band x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Andi) x y))

(rule (lower (has_type (fits_in_64 ty) (band (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Andi) y x))

;;;; Rules for `or` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor x y)))
      (alu_rrr (AluOPRRR.Or) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Ori) x y))

(rule (lower (has_type (fits_in_64 ty) (bor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Ori) y x))

;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bxor x y)))
      (alu_rrr (AluOPRRR.Xor) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bxor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Xori) x y))

(rule (lower (has_type (fits_in_64 ty) (bxor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Xori) y x))



;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


