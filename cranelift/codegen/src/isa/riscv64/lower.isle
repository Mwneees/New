;; riscv64 instruction selection and CLIF-to-MachInst lowering.

;; The main lowering constructor term: takes a clif `Inst` and returns the
;; register(s) within which the lowered instruction's result values live.
(decl lower (Inst) InstOutput)

;;;; Rules for `iconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (iconst (u64_from_imm64 n))))
      (imm ty n))

;;;; Rules for `bconst` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (bconst $false)))
      (imm ty 0))

(rule (lower (has_type ty (bconst $true)))
      (imm ty 1))


;;;; Rules for `null` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type ty (null)))
      (imm ty 0))


;;;; Rules for `iadd` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller

(rule (lower (has_type (fits_in_32 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Addw) x y))

;; Base case, simply adding things in registers.
(rule (lower (has_type (fits_in_64 ty) (iadd x y)))
      (alu_rrr (AluOPRRR.Add) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (iadd x (imm12_from_value y))))
      (alu_rr_imm12 (select_addi ty) x y))

(rule (lower (has_type (fits_in_64 ty) (iadd (imm12_from_value x) y)))
      (alu_rr_imm12 (select_addi ty) y x))

(rule (lower (has_type $I128 (iadd  x y)))
      (i128_arithmetic (I128BinaryOP.Add) x y))

;; i128


;;;; Rules for `isub` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Base case, simply subtracting things in registers.

(rule (lower (has_type (fits_in_64 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Sub) x y))

(rule (lower (has_type (fits_in_32 ty) (isub x y)))
      (alu_rrr (AluOPRRR.Subw) x y))
      
;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub x (imm12_from_value y))))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

;; Special case for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (isub (imm12_from_value y) x)))
      (alu_rr_imm12  (select_addi ty) x (neg_imm12 y)))

(rule (lower (has_type $I128 (isub x y)))
      (i128_arithmetic (I128BinaryOP.Sub) x y))



;;;; Rules for `ineg` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; `i64` and smaller.
(rule (lower (has_type (fits_in_64 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Sub) (zero_reg) x))
(rule (lower (has_type (fits_in_32 ty) (ineg x)))
      (alu_rrr (AluOPRRR.Subw) (zero_reg) x))


;;;; Rules for `imul` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_64 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mul) x y))
(rule (lower (has_type (fits_in_32 ty) (imul x y)))
      (alu_rrr (AluOPRRR.Mulw) x y))

(rule (lower (has_type (fits_in_64 ty) (smulhi x y)))
      (lower_mlhi $true ty x y))

(rule (lower (has_type (fits_in_64 ty) (umulhi x y)))
      (lower_mlhi $false ty x y))

(rule (lower (has_type $I128 (imul x y)))
      (i128_arithmetic (I128BinaryOP.Mul) x y))


;;;; Rules for `div` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_16 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.Divuw) (narrow_int ty x) (narrow_int ty y)))

(rule (lower (has_type (fits_in_32 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Divw) x y))

(rule (lower (has_type (fits_in_32 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.Divuw) x y))

(rule (lower (has_type (fits_in_64 ty) (sdiv x y)))
      (alu_rrr (AluOPRRR.Div) x y))

(rule (lower (has_type (fits_in_64 ty) (udiv x y)))
      (alu_rrr (AluOPRRR.DivU) x y))

;;;; Rules for `rem` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(rule (lower (has_type (fits_in_32 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Remw) x y))

(rule (lower (has_type (fits_in_16 ty) (urem x y)))
      (alu_rrr (AluOPRRR.Remuw) (narrow_int ty x) (narrow_int ty y)))

(rule (lower (has_type (fits_in_32 ty) (urem x y)))
      (alu_rrr (AluOPRRR.Remuw) x y))

(rule (lower (has_type (fits_in_64 ty) (srem x y)))
      (alu_rrr (AluOPRRR.Rem) x y))

(rule (lower (has_type (fits_in_64 ty) (urem x y)))
      (alu_rrr (AluOPRRR.RemU) x y))

;;;; Rules for `and` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band x y)))
      (alu_rrr (AluOPRRR.And) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (band x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Andi) x y))

(rule (lower (has_type (fits_in_64 ty) (band (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Andi) y x))

(rule (lower (has_type $B128 (band x y)))
      (b128_binary (AluOPRRR.And) x y))
(rule (lower (has_type $I128 (band x y)))
      (b128_binary (AluOPRRR.And) x y))


;;;; Rules for `or` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor x y)))
      (alu_rrr (AluOPRRR.Or) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Ori) x y))

(rule (lower (has_type (fits_in_64 ty) (bor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Ori) y x))
(rule (lower (has_type $B128 (bor x y)))
      (b128_binary (AluOPRRR.Or) x y))
(rule (lower (has_type $I128 (bor x y)))
      (b128_binary (AluOPRRR.Or) x y))

;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bxor x y)))
      (alu_rrr (AluOPRRR.Xor) x y))

;; Special cases for when one operand is an immediate that fits in 12 bits.
(rule (lower (has_type (fits_in_64 ty) (bxor x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Xori) x y))

(rule (lower (has_type (fits_in_64 ty) (bxor (imm12_from_value x) y)))
      (alu_rr_imm12 (AluOPRRI.Xori) y x))
(rule (lower (has_type $B128 (bxor x y)))
      (b128_binary (AluOPRRR.Xor) x y))
(rule (lower (has_type $I128 (bxor x y)))
      (b128_binary (AluOPRRR.Xor) x y))


;;;; Rules for `xor` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (bor_not x y)))
      (alu_rrr (AluOPRRR.Orn) x y))
(rule (lower (has_type $B128 (bor_not x y)))
      (b128_binary (AluOPRRR.Orn) x y))
(rule (lower (has_type $I128 (bor_not x y)))
      (b128_binary (AluOPRRR.Orn) x y))


;;;; Rules for `f32const` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; Rules for `bnot` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type $F32 (bnot x)))
      (float_bnot $F32 x))
(rule (lower (has_type $F32 (bnot x)))
      (float_bnot $F64 x))

(rule (lower (has_type fits_in_64 (bnot x)))
      (alu_rr_imm12 (AluOPRRI.Xori) x (imm_from_neg_bits -1)))

(rule (lower (has_type $I128 (bnot x)))
      (bnot_128 x))
(rule (lower (has_type $B128 (bnot x)))
      (bnot_128 x))


;;;; Rules for `bit_reverse` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (bitrev x)))
      (lower_bit_reverse ty x))

(rule (lower (has_type $I128 (bitrev x)))
      (let ((val ValueRegs x)
            (lo_rev Reg (lower_bit_reverse $I64 (value_regs_get val 0)))
            (hi_rev Reg (lower_bit_reverse $I64 (value_regs_get val 1))))
        (value_regs hi_rev lo_rev)))


;;;; Rules for `ctz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (ctz x)))
      (lower_ctz ty x))

;;;; Rules for `clz` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type ty (clz x)))
      (r_clz ty x))

;;;; Rules for `uextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type out (uextend x @ (value_type in))))
      (lower_extend x $false (ty_bits in) (ty_bits out)))

;;;; Rules for `sextend` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type out (sextend x @ (value_type in))))
      (lower_extend x $true (ty_bits in) (ty_bits out)))


;;;; Rules for `band_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty) (band_not x y)))
      (alu_rrr (AluOPRRR.Andn) x y))

(rule (lower (has_type  $I128 (band_not x y)))
      (band_not_128 x y))

;;;; Rules for `popcnt` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_16 ty) (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpopw) (narrow_int ty x) 0))
(rule (lower (has_type $I32 (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpopw) x 0))
(rule (lower (has_type $I64 (popcnt x)))
      (alu_rr_imm12_bit_map (AluOPRRI.Cpop) x 0))


;;;; Rules for `ishl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(ishl x y)))
      (alu_rrr (AluOPRRR.Sllw) x y))
(rule (lower (has_type (fits_in_32 ty)(ishl x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Slliw) x y))
(rule (lower (has_type (fits_in_64 ty)(ishl x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Slli) x y))
(rule (lower (has_type (fits_in_64 ty)(ishl x y)))
      (alu_rrr (AluOPRRR.Sll) x y))
(rule (lower (has_type  $I128 (ishl x y)))
      (i128_arithmetic (I128BinaryOP.Ishl) x y))


;;;; Rules for `ushr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(ushr x y)))
      (alu_rrr (AluOPRRR.Srlw) x y))
(rule (lower (has_type (fits_in_64 ty)(ushr x y)))
      (alu_rrr (AluOPRRR.Srl) x y))
(rule (lower (has_type (fits_in_32 ty)(ushr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.SrliW) x y))
(rule (lower (has_type (fits_in_64 ty)(ushr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Srli) x y))
(rule (lower (has_type  $I128 (ushr x y)))
      (i128_arithmetic (I128BinaryOP.Ushr) x y))


;;;; Rules for `sshr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_32 ty)(sshr x y)))
      (alu_rrr (AluOPRRR.Sraw) x y))
(rule (lower (has_type (fits_in_64 ty)(sshr x y)))
      (alu_rrr (AluOPRRR.Sra) x y))
(rule (lower (has_type (fits_in_32 ty)(sshr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.SrliW) x y))
(rule (lower (has_type (fits_in_64 ty)(sshr x (imm12_from_value y))))
      (alu_rr_imm12 (AluOPRRI.Srli) x y))
(rule (lower (has_type  $I128 (sshr x y)))
      (i128_arithmetic (I128BinaryOP.Sshr) x y))


;;;; Rules for `rotl` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(rotl x y)))
      (lower_rotl ty x y))

(rule (lower (has_type  $I128 (rotl x y)))
      (i128_arithmetic (I128BinaryOP.Rotl) x y))

;;;; Rules for `rotr` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(rotr x y)))
      (lower_rotr ty x y))

(rule (lower (has_type  $I128 (rotr x y)))
      (i128_arithmetic (I128BinaryOP.Rotr) x y))


;;;; Rules for `bxor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(bxor_not x y)))
      (alu_rrr  (AluOPRRR.Xnor) y x))  ;; notice x y order!!!

(rule (lower (has_type  $I128 (bxor_not x y)))
      (i128_arithmetic (I128BinaryOP.Xnor) y x));; notice x y order!!!


;;;; Rules for `xor_not` ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(rule (lower (has_type (fits_in_64 ty)(bor_not x y)))
      (alu_rrr  (AluOPRRR.Orn) x y))  

(rule (lower (has_type  $I128 (bor_not x y)))
      (i128_arithmetic (I128BinaryOP.Orn) x y)) 
