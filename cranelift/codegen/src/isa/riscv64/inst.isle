;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)
    (Nop4)

    ;; load immediate
    (Lui
      (rd WritableReg)
      (imm Imm20))

     (Auipc
      (rd WritableReg)
      (imm Imm20))
    

    ;; An ALU operation with one register sources and a register destination.
    (AluRR
      (alu_op AluOPRR)
      (rd WritableReg)
      (rs Reg))


    ;; An ALU operation with two register sources and a register destination.
    (AluRRR
      (alu_op AluOPRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; An ALU operation with three register sources and a register destination.
    (AluRRRR
      (alu_op AluOPRRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg)
      (rs3 Reg))
      
    ;; An ALU operation with a register source and an immediate-12 source, and a register
    ;; destination.
    (AluRRImm12
      (alu_op AluOPRRI)
      (rd WritableReg)
      (rs Reg)
      (imm12 Imm12))

    ;; An load
    (Load
      (rd WritableReg)
      (op LoadOP)
      (flags MemFlags)
      (from AMode)) 
    ;; An Store 
    (Store
      (to AMode)
      (op StoreOP)
      (flags MemFlags)
      (src Reg))

    (EpiloguePlaceholder)
    (Ret)

     (Extend
      (rd WritableReg)
      (rn Reg)
      (signed bool)
      (from_bits u8)
      (to_bits u8))

      (AjustSp
      (amount i64))


    (Call
      (info BoxCallInfo))

      ;; A machine indirect-call instruction.
    (CallInd
      (info BoxCallIndInfo))


    (TrapIf
      (rs1 Reg)
      (rs2 Reg)
      (cond Cond)
      (trap_code TrapCode))
  
    (Trap
      (trap_code TrapCode))

    (Jal
      (rd WritableReg)
      (dest BranchTarget))
  
     (CondBr
      (taken BranchTarget)
      (not_taken BranchTarget)
      (kind IntegerCompare))

    ;; Load an inline symbol reference.
    (LoadExtName
      (rd WritableReg)
      (name BoxExternalName)
      (offset i64))
    
    ;; Load address referenced by `mem` into `rd`.
    (LoadAddr
      (rd WritableReg)
      (mem AMode))
    
    ;; Marker, no-op in generated code: SP "virtual offset" is adjusted. This
    ;; controls how AMode::NominalSPOffset args are lowered.
    (VirtualSPOffsetAdj
      (amount i64))

    ;; A MOV instruction. These are encoded as OrR's (AluRRR form) but we
    ;; keep them separate at the `Inst` level for better pretty-printing
    ;; and faster `is_move()` logic.
    (Mov
      (rd WritableReg)
      (rm Reg)
      (ty Type))

    (Fence)

    (FenceI)

    (ECall)

    (EBreak)

    ;; An instruction guaranteed to always be undefined and to trigger an illegal instruction at
    ;; runtime.
    (Udf
      (trap_code TrapCode))
    
    ;; float flags operation
    (FloatFlagOperation
      (op FloatFlagOp)
      (rd   WritableReg)
      (rs OptionReg)
      (imm OptionImm12))

    ;; a jump and link register operation 
    (Jalr
      ;;Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0.
      (rd WritableReg)
      (base Reg)
      (offset Imm12))

    ;; 
    (Atomic 
      (op AtomicOP)
      (rd WritableReg)
      (addr Reg)
      (src Reg)
      (aq bool)
      (rl bool))
    

    ;; a float compare 
    (Ffcmp 
      (rd WritableReg)
      (cc FloatCC)
      (ty Type)
      (rs1 Reg)
      (rs2 Reg))

    ;; select x or y base on condition 
    (Select 
      (dst VecWritableReg)
      (ty Type)
      (conditon Reg)
      (x ValueRegs)
      (y ValueRegs))

    (ReferenceValid
      (rd WritableReg)
      (op ReferenceValidOP)
      (x Reg))
    
    (BrTable
      (index Reg)
      (tmp1 WritableReg)
      (default_ BranchTarget)
      (targets VecBranchTarget))

    ;; atomic compare and set operation
    (AtomicCas
      (t0 WritableReg)
      (dst WritableReg)
      (e Reg)
      (addr Reg)
      (v Reg)
      (ty Type))
    ;; select x or y base on op_code 
    (IntSelect
    (op IntSelectOP)
    (dst VecWritableReg)
    (x ValueRegs)
    (y ValueRegs)
    (ty Type))

))


(type IntSelectOP (enum
  (Imax)
  (Umax)
  (Imin)
  (Umin)
))


(type ReferenceValidOP(enum
  (IsNull)
  (IsInvalid)
))


(type AtomicOP (enum
  (LrW)
  (ScW)
  (AmoswapW)
  (AmoaddW)
  (AmoxorW)
  (AmoandW)
  (AmoorW)
  (AmominW)
  (AmomaxW)
  (AmominuW)
  (AmomaxuW)
  (LrD)
  (ScD)
  (AmoswapD)
  (AmoaddD)
  (AmoxorD)
  (AmoandD)
  (AmoorD)
  (AmominD)
  (AmomaxD)
  (AmominuD)
  (AmomaxuD)
))

(type FloatFlagOp (enum 
  (Frcsr)
  (Frrm)
  (Frflags)
  (Fsrmi)
  (Fsflagsi)
  (Fscsr)
  (Fsrm)
  (Fsflags)
))

(type AluOPRRRR(enum 
  ;; float32
  (FmaddS)
  (FmsubS)
  (FnmsubS)
  (FnmaddS)
  ;; float64
  (FmaddD)
  (FmsubD)
  (FnmsubD)
  (FnmaddD)
))

(type FClassResult(enum 
  ;;0 rs1 is −∞.
  (NegInfinite)
  ;; 1 rs1 is a negative normal number.
  (NegNormal)
  ;; 2 rs1 is a negative subnormal number.
  (NegSubNormal)
  ;; 3 rs1 is −0.
  (NegZero)
  ;; 4 rs1 is +0.
  (PosZero)
  ;; 5 rs1 is a positive subnormal number.
  (PosSubNormal)
  ;; 6 rs1 is a positive normal number.
  (PosNormal)
  ;; 7 rs1 is +∞.
  (PosInfinite)
  ;; 8 rs1 is a signaling NaN.
  (SNaN)
  ;; 9 rs1 is a quiet NaN.
  (QNaN)
))

(type AluOPRR (enum 
  ;; RV32F Standard Extension
  (FsqrtS)
  (FcvtWS)
  (FcvtWuS)
  (FmvXW)
  (FclassS)
  (FcvtSw)
  (FcvtSwU)
  (FmvWX)



  ;; RV64F Standard Extension (in addition to RV32F)
  (FcvtLS)
  (FcvtLuS)
  (FcvtSL)
  (FcvtSLU)
  

  ;; RV64D Standard Extension (in addition to RV32D)
  (FcvtLd)
  (FcvtLuD)
  (FmvXD)
  (FcvtDL)
  (FcvtDLu)
  (FmvDX)

  ;; RV32D Standard Extension
  (FsqrtD)
  (FcvtSd)
  (FcvtDS)
  (FclassD)
  (FcvtWD)
  (FcvtWuD)
  (FcvtDW)
  (FcvtDWU)
  
))

(type LoadOP (enum  
  (Lb)
  (Lh)
  (Lw)
  (Lbu)
  (Lhu)
  (Lwu)
  (Ld)
  (Flw)
  (Fld)
))

(type StoreOP(enum
  (Sb)
  (Sh)
  (Sw)
  (Sd)
  (Fsw)
  (Fsd)
))

(type AluOPRRR (enum 
  ;; base set
  (Add)
  (Sub)
  (Sll)
  (Slt)
  (SltU)
  (Xor)
  (Srl)
  (Sra)
  (Or)
  (And)
  
  ;; RV64I Base Instruction Set (in addition to RV32I)
  (Addw)
  (Subw)
  (Sllw)
  (Srlw)
  (Sraw)

  
  
  ;;RV32M Standard Extension
  (Mul)
  (Mulh)
  (Mulhsu)
  (Mulhu)
  (Div)
  (DivU)
  (Rem)
  (RemU)

  ;; RV64M Standard Extension (in addition to RV32M)

  (Mulw)
  (Divw)
  (Divuw)
  (Remw)
  (Remuw)

  ;; RV32F Standard Extension

  (FaddS)
  (FsubS)
  (FmulS)
  (FdivS)

  (FsgnjS)
  (FsgnjnS)
  (FsgnjxS)
  (FminS)
  (FmaxS)
  (FeqS)
  (FltS)
  (FleS)
 
  ;; RV32D Standard Extension
  (FaddD)
  (FsubD)
  (FmulD)
  (FdivD)
  (FsgnjD)
  (FsgnjnD)
  (FsgnjxD)
  (FminD)
  (FmaxD)
  (FeqD)
  (FltD)
  (FleD)

))


(type AluOPRRI (enum 
  (Addi)
  (Slti)
  (SltiU)
  (Xori)
  (Ori)
  (Andi)
  (Slli)
  (Srli)
  (Srai)
  (Addiw)
  (Slliw)
  (SrliW)
  (Sraiw)
))

;; The 2-bit floating-point format field fmt is encoded as shown in Table 8.3. It is set to S (00) for all
;; instructions in the F extension.
(type OPFPFMT (enum 
  ;; 32-bit single-precision
  (S)
  ;;64-bit double-precision
  (D)
  ;; reserved
  ;;(Reserved)
  ;; 128-bit quad-precision
  (Q)
)) 


(type FloatRoundingMode (enum 
  ;; Round to Nearest, ties to Even
  (RNE)
  ;; Round towards Zero
  (RTZ)
  ;;  Round Down (towards −∞)
  (RDN)
  ;; Round Up (towards +∞)
  (RUP)
  ;; Round to Nearest, ties to Max Magnitude
  (RMM)
))

(type FFlagsException (enum
  ;; Invalid Operation
  (NV)
  ;; Divide by Zero
  (DZ)
  ;; Overflow
  (OF)
  ;; Underflow
  (UF)
  ;; Inexact
  (NX)
))


(type VecBranchTarget (primitive VecBranchTarget))
(type BoxCallInfo (primitive BoxCallInfo))
(type BoxCallIndInfo (primitive BoxCallIndInfo))
(type IntegerCompare (primitive IntegerCompare))
(type AMode (primitive AMode))
(type OptionReg (primitive OptionReg))
(type OptionImm12 (primitive OptionImm12))
(type Imm12 (primitive Imm12))
(type UImm5 (primitive UImm5))
(type Imm20 (primitive Imm20))
(type Imm3 (primitive Imm3))
(type BranchTarget (primitive BranchTarget))

(type ExtendOp 
  (enum
    (UXTB)
    (UXTH)
    (UXTW)
    (UXTD)
    (SXTB)
    (SXTH)
    (SXTW)
    (SXTD)
))


(type Cond  
  (enum
    (Eq)
    (Ne)
    (Lt)
    (Ltu)
    (Ge)
    (Geu)
))


;; Helper for creating the zero register.
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;; for load immediate
(decl imm (Type u64) Reg)
(extern constructor imm imm)

;;
(decl imm12_from_u64 (Imm12) u64)
(extern extractor imm12_from_u64 imm12_from_u64)


(decl writable_zero_reg () WritableReg)
(extern constructor writable_zero_reg writable_zero_reg)


;; Helper for emitting `MInst.AluRR` instructions.
(decl alu_rr (AluOPRR Reg) Reg)
(rule (alu_rr op src )
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRR op dst src))))
        dst))


;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (AluOPRRR Reg Reg) Reg)
(rule (alu_rrr op src1 src2)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRR op dst src1 src2))))
        dst))


;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrrr (AluOPRRRR Reg Reg Reg) Reg)
(rule (alu_rrrr op src1 src2 src3)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRRR op dst src1 src2 src3))))
        dst))


;; Helper for emitting `MInst.AluRRImm12` instructions.
(decl alu_rr_imm12 (AluOPRRI Reg Imm12) Reg)
(rule (alu_rr_imm12 op src imm)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRImm12 op dst src imm))))
        dst))



;; Helper for get negative of Imm12 
(decl neg_imm12 (Imm12) Imm12)
(extern constructor neg_imm12 neg_imm12) 


;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.
(decl imm12_from_value (Imm12) Value)
(extractor
  (imm12_from_value n)
  (def_inst (iconst (u64_from_imm64 (imm12_from_u64 n)))))

(decl select_addi (Type) AluOPRRI)
(rule (select_addi (fits_in_32 ty)) (AluOPRRI.Addiw))
(rule (select_addi (fits_in_64 ty)) (AluOPRRI.Addi))



