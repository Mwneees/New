;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)
    (Nop4)

    ;; load immediate
    (Lui
      (rd WritableReg)
      (imm Imm20))

     (Auipc
      (rd WritableReg)
      (imm Imm20))
    

    ;; An ALU operation with one register sources and a register destination.
    (FpuRR
      (alu_op FpuOPRR)
      (frm OptionFloatRoundingMode)
      (rd WritableReg)
      (rs Reg))


    ;; An ALU operation with two register sources and a register destination.
    (AluRRR
      (alu_op AluOPRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; An ALU operation with two register sources and a register destination.
    (FpuRRR
      (alu_op FpuOPRRR)
      (frm OptionFloatRoundingMode)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; An ALU operation with three register sources and a register destination.
    (FpuRRRR
      (alu_op FpuOPRRRR)
      (frm OptionFloatRoundingMode)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg)
      (rs3 Reg))
      
    ;; An ALU operation with a register source and an immediate-12 source, and a register
    ;; destination.
    (AluRRImm12
      (alu_op AluOPRRI)
      (rd WritableReg)
      (rs Reg)
      (imm12 Imm12))

    ;; An load
    (Load
      (rd WritableReg)
      (op LoadOP)
      (flags MemFlags)
      (from AMode)) 
    ;; An Store 
    (Store
      (to AMode)
      (op StoreOP)
      (flags MemFlags)
      (src Reg))

    (EpiloguePlaceholder)
    (Ret (rets VecReg))

     (Extend
      (rd WritableReg)
      (rn Reg)
      (signed bool)
      (from_bits u8)
      (to_bits u8))
  
    (AjustSp
      (amount i64))
    (Call
      (info BoxCallInfo))

      ;; A machine indirect-call instruction.
    (CallInd
      (info BoxCallIndInfo))


    (TrapIf
      (cc IntCC)
      (x ValueRegs)
      (y ValueRegs)
      (ty Type)
      (trap_code TrapCode))

    (TrapFf
      (cc FloatCC)
      (x Reg)
      (y Reg)
      (ty Type)
      (tmp WritableReg)
      (trap_code TrapCode))

    (Jal
      ;; (rd WritableReg) don't use 
      (dest BranchTarget))
  
     (CondBr
      (taken BranchTarget)
      (not_taken BranchTarget)
      (kind IntegerCompare))

    ;; Load an inline symbol reference.
    (LoadExtName
      (rd WritableReg)
      (name BoxExternalName)
      (offset i64))
    
    ;; Load address referenced by `mem` into `rd`.
    (LoadAddr
      (rd WritableReg)
      (mem AMode))
    
    ;; Marker, no-op in generated code: SP "virtual offset" is adjusted. This
    ;; controls how AMode::NominalSPOffset args are lowered.
    (VirtualSPOffsetAdj
      (amount i64))

    ;; A MOV instruction. These are encoded as OrR's (AluRRR form) but we
    ;; keep them separate at the `Inst` level for better pretty-printing
    ;; and faster `is_move()` logic.
    (Mov
      (rd WritableReg)
      (rm Reg)
      (ty Type))

    (Fence)

    (FenceI)

    (ECall)

    (EBreak)

    ;; An instruction guaranteed to always be undefined and to trigger an illegal instruction at
    ;; runtime.
    (Udf
      (trap_code TrapCode))
    ;; a jump and link register operation 
    (Jalr
      ;;Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0.
      (rd WritableReg)
      (base Reg)
      (offset Imm12))

    ;; atomic operations.
    (Atomic 
      (op AtomicOP)
      (rd WritableReg)
      (addr Reg)
      (src Reg)
      (amo AMO))
    

    ;; a float compare 
    (Fcmp 
      (rd WritableReg)
      (cc FloatCC)
      (ty Type)
      (rs1 Reg)
      (rs2 Reg))

    ;; select x or y base on condition 
    (Select 
      (dst VecWritableReg)
      (ty Type)
      (conditon Reg)
      (x ValueRegs)
      (y ValueRegs))

    (ReferenceCheck
      (rd WritableReg)
      (op ReferenceCheckOP)
      (x Reg))
    
    (BrTable
      (index Reg)
      (tmp1 WritableReg)
      (default_ BranchTarget)
      (targets VecBranchTarget))

    ;; atomic compare and set operation
    (AtomicCas
      (t0 WritableReg)
      (dst WritableReg)
      (e Reg)
      (addr Reg)
      (v Reg)
      (ty Type))
    ;; select x or y base on op_code 
    (IntSelect
      (op IntSelectOP)
      (dst VecWritableReg)
      (x ValueRegs)
      (y ValueRegs)
      (ty Type))
      
    (Csr
      (csr_op CsrOP)
      (rd WritableReg)
      (rs OptionReg)
      (imm OptionUimm5)
      (csr CsrAddress))
    (Icmp
      (cc IntCC)
      (rd WritableReg)
      (a ValueRegs) 
      (b ValueRegs)
      (ty Type))
    (Cls
      (rs Reg)
      (rd WritableReg)
      (ty Type))
    (SelectReg
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg)
      (condition IntegerCompare))
    
    (FcvtToIntSat
      (rd WritableReg)
      (rs Reg)
      (tmp WritableReg)
      (is_signed bool)
      (in_type Type)
      (out_type Type))
    (SelectIf 
      (if_spectre_guard bool)
      (rd VecWritableReg)
      (cmp_x ValueRegs)
      (cmp_y ValueRegs)
      (cc IntCC)
      (cmp_ty Type)
      (x ValueRegs)
      (y ValueRegs))
    (RawData (data VecU8))
))

(type CsrOP(enum 
  (Csrrw)
  (Csrrs)
  (Csrrc)
  (Csrrwi)
  (Csrrsi)
  (Csrrci)
))


(type I128OP (enum 
  (Add)
  (Sub)
  (Mul)
  (Div)
  (Rem)
))


(type IntSelectOP (enum
  (Imax)
  (Umax)
  (Imin)
  (Umin)
))



(type ReferenceCheckOP(enum
  (IsNull)
  (IsInvalid)
))

(type AtomicOP (enum
  (LrW)
  (ScW)
  (AmoswapW)
  (AmoaddW)
  (AmoxorW)
  (AmoandW)
  (AmoorW)
  (AmominW)
  (AmomaxW)
  (AmominuW)
  (AmomaxuW)
  (LrD)
  (ScD)
  (AmoswapD)
  (AmoaddD)
  (AmoxorD)
  (AmoandD)
  (AmoorD)
  (AmominD)
  (AmomaxD)
  (AmominuD)
  (AmomaxuD)
))

 
(type FpuOPRRRR(enum 
  ;; float32
  (FmaddS)
  (FmsubS)
  (FnmsubS)
  (FnmaddS)
  ;; float64
  (FmaddD)
  (FmsubD)
  (FnmsubD)
  (FnmaddD)
))

(type FClassResult(enum 
  ;;0 rs1 is −∞.
  (NegInfinite)
  ;; 1 rs1 is a negative normal number.
  (NegNormal)
  ;; 2 rs1 is a negative subnormal number.
  (NegSubNormal)
  ;; 3 rs1 is −0.
  (NegZero)
  ;; 4 rs1 is +0.
  (PosZero)
  ;; 5 rs1 is a positive subnormal number.
  (PosSubNormal)
  ;; 6 rs1 is a positive normal number.
  (PosNormal)
  ;; 7 rs1 is +∞.
  (PosInfinite)
  ;; 8 rs1 is a signaling NaN.
  (SNaN)
  ;; 9 rs1 is a quiet NaN.
  (QNaN)
))

(type FpuOPRR (enum 
  ;; RV32F Standard Extension
  (FsqrtS)
  (FcvtWS)
  (FcvtWuS)
  (FmvXW)
  (FclassS)
  (FcvtSw)
  (FcvtSwU)
  (FmvWX)


  ;; RV64F Standard Extension (in addition to RV32F)
  (FcvtLS)
  (FcvtLuS)
  (FcvtSL)
  (FcvtSLU)
  

  ;; RV64D Standard Extension (in addition to RV32D)
  (FcvtLD)
  (FcvtLuD)
  (FmvXD)
  (FcvtDL)
  (FcvtDLu)
  (FmvDX)

  ;; RV32D Standard Extension
  (FsqrtD)
  (FcvtSD)
  (FcvtDS)
  (FclassD)
  (FcvtWD)
  (FcvtWuD)
  (FcvtDW)
  (FcvtDWU)
  
  ;; bitmapip
  
))

(type LoadOP (enum  
  (Lb)
  (Lh)
  (Lw)
  (Lbu)
  (Lhu)
  (Lwu)
  (Ld)
  (Flw)
  (Fld)
))

(type StoreOP(enum
  (Sb)
  (Sh)
  (Sw)
  (Sd)
  (Fsw)
  (Fsd)
))

(type AluOPRRR (enum 
  ;; base set
  (Add)
  (Sub)
  (Sll)
  (Slt)
  (SltU)
  (Xor)
  (Srl)
  (Sra)
  (Or)
  (And)
  
  ;; RV64I Base Instruction Set (in addition to RV32I)
  (Addw)
  (Subw)
  (Sllw)
  (Srlw)
  (Sraw)

  
  ;;RV32M Standard Extension
  (Mul)
  (Mulh)
  (Mulhsu)
  (Mulhu)
  (Div)
  (DivU)
  (Rem)
  (RemU)

  ;; RV64M Standard Extension (in addition to RV32M)

  (Mulw)
  (Divw)
  (Divuw)
  (Remw)
  (Remuw)

  ;; bitmapip
  (Adduw)
  (Andn)
  (Bclr)
  (Bext)
  (Binv)
  (Bset)
  (Clmul)
  (Clmulh)
  (Clmulr)
  (Max)
  (Maxu)
  (Min)
  (Minu)
  (Orn)
  (Rol)
  (Rolw)
  (Ror)
  (Rorw)
  (Sh1add)
  (Sh1adduw)
  (Sh2add)
  (Sh2adduw)
  (Sh3add)
  (Sh3adduw)
  (Xnor)
))


(type FpuOPRRR (enum
  ;; RV32F Standard Extension
  (FaddS)
  (FsubS)
  (FmulS)
  (FdivS)

  (FsgnjS)
  (FsgnjnS)
  (FsgnjxS)
  (FminS)
  (FmaxS)
  (FeqS)
  (FltS)
  (FleS)
 
  ;; RV32D Standard Extension
  (FaddD)
  (FsubD)
  (FmulD)
  (FdivD)
  (FsgnjD)
  (FsgnjnD)
  (FsgnjxD)
  (FminD)
  (FmaxD)
  (FeqD)
  (FltD)
  (FleD)
))



(type AluOPRRI (enum 
  (Addi)
  (Slti)
  (SltiU)
  (Xori)
  (Ori)
  (Andi)
  (Slli)
  (Srli)
  (Srai)
  (Addiw)
  (Slliw)
  (SrliW)
  (Sraiw)
  (Bclri)
  (Bexti)
  (Binvi)
  (Bseti)
  (Rori)
  (Roriw)
  (SlliUw)
  (Clz)
  (Clzw)
  (Cpop)
  (Cpopw)
  (Ctz)
  (Ctzw)
  (Rev8)
  (Sextb)
  (Sexth)
  (Zexth)
  (Orcb)
  (Brev8)
))

;; The 2-bit floating-point format field fmt is encoded as shown in Table 8.3. It is set to S (00) for all
;; instructions in the F extension.
(type OPFPFMT (enum 
  ;; 32-bit single-precision
  (S)
  ;;64-bit double-precision
  (D)
  ;; reserved
  ;;(Reserved)
  ;; 128-bit quad-precision
  (Q)
)) 


(type FRM (enum 
  ;; Round to Nearest, ties to Even
  (RNE)
  ;; Round towards Zero
  (RTZ)
  ;;  Round Down (towards −∞)
  (RDN)
  ;; Round Up (towards +∞)
  (RUP)
  ;; Round to Nearest, ties to Max Magnitude
  (RMM)
  ;; In instruction’s rm field, selects dynamic rounding mode;
  ;;In Rounding Mode register, Invalid.
  (Fcsr)
))

(type FFlagsException (enum
  ;; Invalid Operation
  (NV)
  ;; Divide by Zero
  (DZ)
  ;; Overflow
  (OF)
  ;; Underflow
  (UF)
  ;; Inexact
  (NX)
))


(type VecBranchTarget (primitive VecBranchTarget))
(type BoxCallInfo (primitive BoxCallInfo))
(type BoxCallIndInfo (primitive BoxCallIndInfo))
(type IntegerCompare (primitive IntegerCompare))
(type AMode (primitive AMode))
(type OptionReg (primitive OptionReg))
(type OptionImm12 (primitive OptionImm12))
(type OptionUimm5 (primitive OptionUimm5))
(type Imm12 (primitive Imm12))
(type UImm5 (primitive UImm5))
(type Imm20 (primitive Imm20))
(type Imm3 (primitive Imm3))
(type BranchTarget (primitive BranchTarget))
(type CsrAddress (primitive CsrAddress))
(type OptionFloatRoundingMode (primitive OptionFloatRoundingMode))
(type VecU8 (primitive VecU8))
(type AMO (primitive AMO))


;; Helper for creating the zero register.
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;; for load immediate
(decl imm (Type u64) Reg)
(extern constructor imm imm)

;; for load immediate
(decl imm_from_bits (u64) Imm12)
(extern constructor imm_from_bits imm_from_bits)

(decl imm_from_neg_bits (i64) Imm12)
(extern constructor imm_from_neg_bits imm_from_neg_bits)
;;
(decl imm12_from_u64 (Imm12) u64)
(extern extractor imm12_from_u64 imm12_from_u64)

(decl writable_zero_reg () WritableReg)
(extern constructor writable_zero_reg writable_zero_reg)

(decl gen_default_frm() OptionFloatRoundingMode)
(extern constructor gen_default_frm gen_default_frm)


;; Helper for emitting `MInst.FpuRR` instructions.
(decl fpu_rr (FpuOPRR Type Reg) Reg)
(rule (fpu_rr op ty src )
      (let ((dst WritableReg (temp_writable_reg ty))
            (_ Unit (emit (MInst.FpuRR op (gen_default_frm) dst src))))
        dst))

;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (AluOPRRR Type Reg Reg) Reg)
(rule (alu_rrr op ty src1 src2)
      (let ((dst WritableReg (temp_writable_reg ty))
            (_ Unit (emit (MInst.AluRRR op dst src1 src2))))
        dst))

(decl pack_float_rounding_mode(FRM)OptionFloatRoundingMode)
(extern constructor pack_float_rounding_mode pack_float_rounding_mode)

;; Helper for emitting `MInst.AluRRR` instructions.
(decl fpu_rrr (FpuOPRRR Type Reg Reg) Reg)
(rule (fpu_rrr op ty src1 src2)
      (let ((dst WritableReg (temp_writable_reg ty))
            (_ Unit (emit (MInst.FpuRRR op (gen_default_frm) dst src1 src2))))
        dst))


;; Helper for emitting `MInst.FpuRRRR` instructions.
(decl fpu_rrrr (FpuOPRRRR Type Reg Reg Reg) Reg)
(rule (fpu_rrrr op ty src1 src2 src3)
      (let ((dst WritableReg (temp_writable_reg ty))
            (_ Unit (emit (MInst.FpuRRRR op (gen_default_frm) dst src1 src2 src3))))
        dst))


;; Helper for emitting `MInst.AluRRImm12` instructions.
(decl alu_rr_imm12 (AluOPRRI Reg Imm12) Reg)
(rule (alu_rr_imm12 op src imm)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRImm12 op dst src imm))))
        dst))

;; Helper for narrow down int to it's bits.
(decl narrow_int(Type Reg) Reg)
(rule (narrow_int $I8 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 56)) (imm_from_bits 56))) 
(rule (narrow_int $I16 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 48)) (imm_from_bits 48)))
(rule (narrow_int $I32 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 32)) (imm_from_bits 32)))

;; Helper for get negative of Imm12 
(decl neg_imm12 (Imm12) Imm12)
(extern constructor neg_imm12 neg_imm12) 


;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.
(decl imm12_from_value (Imm12) Value)
(extractor
  (imm12_from_value n)
  (def_inst (iconst (u64_from_imm64 (imm12_from_u64 n)))))

(decl select_addi (Type) AluOPRRI)
(rule (select_addi (fits_in_32 ty)) (AluOPRRI.Addiw))
(rule (select_addi (fits_in_64 ty)) (AluOPRRI.Addi))

(decl lower_float_bnot (Type  Reg) Reg)
(extern constructor lower_float_bnot lower_float_bnot)

(decl bnot_128 (ValueRegs) ValueRegs)
(extern constructor bnot_128 bnot_128)


(decl i128_arithmetic (I128OP ValueRegs ValueRegs) ValueRegs)
(extern constructor i128_arithmetic i128_arithmetic)

(decl lower_bit_reverse (Type Reg)Reg)
(extern constructor lower_bit_reverse lower_bit_reverse)

(decl lower_ctz (Type ValueRegs)ValueRegs)
(extern constructor lower_ctz lower_ctz)

(decl lower_clz (Type ValueRegs)Reg)
(extern constructor lower_clz lower_clz)

(decl lower_extend(Reg bool u8 u8 )ValueRegs)
(extern constructor lower_extend lower_extend)

(decl lower_band_not_i128(ValueRegs ValueRegs)ValueRegs)
(extern constructor lower_band_not_i128 lower_band_not_i128)


(decl lower_b128_binary(AluOPRRR ValueRegs ValueRegs) ValueRegs)
(extern constructor lower_b128_binary lower_b128_binary)

(decl lower_mlhi (bool Type Reg Reg)Reg)
(extern constructor lower_mlhi lower_mlhi)


(decl lower_rotl(Type Reg Reg) Reg)
(extern constructor lower_rotl lower_rotl)

(decl lower_rotr(Type Reg Reg) Reg)
(extern constructor lower_rotr lower_rotr)


(decl lower_cls(Reg Type) Reg)
(extern constructor lower_cls lower_cls)

(decl lower_i128_xnor(ValueRegs ValueRegs)ValueRegs)
(extern constructor lower_i128_xnor lower_i128_xnor)

(decl lower_float_xnot (Type Reg Reg) Reg)
(extern constructor lower_float_xnot lower_float_xnot)

(decl lower_popcnt_i128(ValueRegs) ValueRegs)
(extern constructor lower_popcnt_i128 lower_popcnt_i128)

(decl lower_i128_rotate(bool ValueRegs ValueRegs) ValueRegs)
(extern constructor lower_i128_rotate lower_i128_rotate)


(decl lower_float_abs (Type  Reg) Reg)
(extern constructor lower_float_abs lower_float_abs)

(decl lower_float_neg (Type  Reg) Reg)
(extern constructor lower_float_neg lower_float_neg)


(decl lower_i128_logical_shift(bool bool ValueRegs ValueRegs)ValueRegs)
(extern constructor lower_i128_logical_shift lower_i128_logical_shift)

(decl valueregs_2_reg(Reg) Value)
(extern extractor valueregs_2_reg valueregs_2_reg)

(convert ValueRegs Reg valueregs_2_reg)

(decl lower_cls_i128 (ValueRegs)ValueRegs)
(extern constructor lower_cls_i128 lower_cls_i128)

(decl imm12_const (i32) Imm12)
(extern constructor imm12_const imm12_const)

(decl con_amode(Reg i64 Type)AMode)
(extern constructor con_amode con_amode)

;; helper function to load from memory.
(decl con_load(Reg i64 LoadOP Type MemFlags)Reg)
(rule 
  (con_load base offset op ty flags) 
  (let
    (
      (tmp WritableReg (temp_writable_reg $I64))
      (_ Unit (emit (MInst.Load tmp op flags (con_amode base offset ty))))
    )
    tmp
  )
)

;; some instruction have no return value.
(decl no_return()InstOutput)
(extern constructor no_return no_return)


;; helper function to store to memory.
(decl con_store(Reg i64 StoreOP Type MemFlags Reg)InstOutput)
(rule 
  (con_store base offset op ty flags src)
  (let
    (
      (_ Unit (emit (MInst.Store (con_amode base offset ty) op flags src)))
    )
    (no_return)
  )
)



(decl valid_atomic_transaction (Type) Type)
(extern extractor valid_atomic_transaction valid_atomic_transaction)

;;helper function.
;;construct an atomic instruction.
(decl con_atomic (AtomicOP Reg Reg AMO)Reg)
(rule 
  (con_atomic op addr src amo)
  (let
    (
      (tmp WritableReg (temp_writable_reg $I64))
      (_ Unit (emit (MInst.Atomic op tmp addr src amo)))
    )
    tmp
  )
)

;; helper function 
(decl get_atomic_rmw_op(Type AtomicRmwOp)AtomicOP)
(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Add))
  (AtomicOP.AmoaddW)
)
(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Add))
  (AtomicOP.AmoaddD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.And))
  (AtomicOP.AmoandW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.And))
  (AtomicOP.AmoandD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Or))
  (AtomicOP.AmoorW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Or))
  (AtomicOP.AmoorD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Smax))
  (AtomicOP.AmomaxW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Smax))
  (AtomicOP.AmomaxD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Smin))
  (AtomicOP.AmominW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Smin))
  (AtomicOP.AmominD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Umax))
  (AtomicOP.AmomaxuW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Umax))
  (AtomicOP.AmomaxuD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Umin))
  (AtomicOP.AmominuW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Umin))
  (AtomicOP.AmominuD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Xchg))
  (AtomicOP.AmoswapW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Xchg))
  (AtomicOP.AmoswapD)
)

(rule 
  (get_atomic_rmw_op $I32 (AtomicRmwOp.Xor))
  (AtomicOP.AmoxorW)
)

(rule 
  (get_atomic_rmw_op $I64 (AtomicRmwOp.Xor))
  (AtomicOP.AmoxorD)
)

(decl atomic_rmw_amo()AMO)
(extern constructor atomic_rmw_amo atomic_rmw_amo)

(decl con_atomic_load(Reg Type)Reg)
(extern constructor con_atomic_load con_atomic_load)

(decl con_atomic_store(Reg Type Reg)Reg)
(extern constructor con_atomic_store con_atomic_store)

;; helper function to inverse all bits.
(decl con_bit_not(Reg)Reg)
(rule (con_bit_not r) 
  (alu_rr_imm12 (AluOPRRI.Xori) r (imm12_const -1)))

