;; Instruction formats.
(type MInst
  (enum
    ;; A no-op of zero size.
    (Nop0)
    (Nop4)

    ;; load immediate
    (Lui
      (rd WritableReg)
      (imm Imm20))

     (Auipc
      (rd WritableReg)
      (imm Imm20))
    

    ;; An ALU operation with one register sources and a register destination.
    (AluRR
      (alu_op AluOPRR)
      (rd WritableReg)
      (rs Reg))


    ;; An ALU operation with two register sources and a register destination.
    (AluRRR
      (alu_op AluOPRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg))

    ;; An ALU operation with three register sources and a register destination.
    (AluRRRR
      (alu_op AluOPRRRR)
      (rd WritableReg)
      (rs1 Reg)
      (rs2 Reg)
      (rs3 Reg))
      
    ;; An ALU operation with a register source and an immediate-12 source, and a register
    ;; destination.
    (AluRRImm12
      (alu_op AluOPRRI)
      (rd WritableReg)
      (rs Reg)
      (imm12 Imm12))

    ;; An load
    (Load
      (rd WritableReg)
      (op LoadOP)
      (flags MemFlags)
      (from AMode)) 
    ;; An Store 
    (Store
      (to AMode)
      (op StoreOP)
      (flags MemFlags)
      (src Reg))

    (EpiloguePlaceholder)
    (Ret (rets VecReg))

     (Extend
      (rd WritableReg)
      (rn Reg)
      (signed bool)
      (from_bits u8)
      (to_bits u8))

      (AjustSp
      (amount i64))


    (Call
      (info BoxCallInfo))

      ;; A machine indirect-call instruction.
    (CallInd
      (info BoxCallIndInfo))


    (TrapIf
      (rs1 Reg)
      (rs2 Reg)
      (cond Cond)
      (trap_code TrapCode))
  
    (Trap
      (trap_code TrapCode))

    (Jal
      ;; (rd WritableReg) don't use 
      (dest BranchTarget))
  
     (CondBr
      (taken BranchTarget)
      (not_taken BranchTarget)
      (kind IntegerCompare))

    ;; Load an inline symbol reference.
    (LoadExtName
      (rd WritableReg)
      (name BoxExternalName)
      (offset i64))
    
    ;; Load address referenced by `mem` into `rd`.
    (LoadAddr
      (rd WritableReg)
      (mem AMode))
    
    ;; Marker, no-op in generated code: SP "virtual offset" is adjusted. This
    ;; controls how AMode::NominalSPOffset args are lowered.
    (VirtualSPOffsetAdj
      (amount i64))

    ;; A MOV instruction. These are encoded as OrR's (AluRRR form) but we
    ;; keep them separate at the `Inst` level for better pretty-printing
    ;; and faster `is_move()` logic.
    (Mov
      (rd WritableReg)
      (rm Reg)
      (ty Type))

    (Fence)

    (FenceI)

    (ECall)

    (EBreak)

    ;; An instruction guaranteed to always be undefined and to trigger an illegal instruction at
    ;; runtime.
    (Udf
      (trap_code TrapCode))
    
    ;; float flags operation
    (FloatFlagOperation
      (op FloatFlagOp)
      (rd   WritableReg)
      (rs OptionReg)
      (imm OptionImm12))

    ;; a jump and link register operation 
    (Jalr
      ;;Plain unconditional jumps (assembler pseudo-op J) are encoded as a JAL with rd=x0.
      (rd WritableReg)
      (base Reg)
      (offset Imm12))

    ;; 
    (Atomic 
      (op AtomicOP)
      (rd WritableReg)
      (addr Reg)
      (src Reg)
      (aq bool)
      (rl bool))
    

    ;; a float compare 
    (Ffcmp 
      (rd WritableReg)
      (cc FloatCC)
      (ty Type)
      (rs1 Reg)
      (rs2 Reg))

    ;; select x or y base on condition 
    (Select 
      (dst VecWritableReg)
      (ty Type)
      (conditon Reg)
      (x ValueRegs)
      (y ValueRegs))

    (ReferenceValid
      (rd WritableReg)
      (op ReferenceValidOP)
      (x Reg))
    
    (BrTable
      (index Reg)
      (tmp1 WritableReg)
      (default_ BranchTarget)
      (targets VecBranchTarget))

    ;; atomic compare and set operation
    (AtomicCas
      (t0 WritableReg)
      (dst WritableReg)
      (e Reg)
      (addr Reg)
      (v Reg)
      (ty Type))
    ;; select x or y base on op_code 
    (IntSelect
      (op IntSelectOP)
      (dst VecWritableReg)
      (x ValueRegs)
      (y ValueRegs)
      (ty Type))
      
    (I128Arithmetic
      (op I128OP)
      (t0 WritableReg)
      (t1 WritableReg)
      (dst VecWritableReg)
      (x ValueRegs)
      (y ValueRegs))
    
    (Csr
      (csr_op CsrOP)
      (rd WritableReg)
      (rs OptionReg)
      (imm OptionUimm5)
      (csr CsrAddress))
    (Icmp
      (cc IntCC)
      (rd WritableReg)
      (a ValueRegs) 
      (b ValueRegs)
      (ty Type))
    (Cls
      (rs Reg)
      (rd WritableReg)
      (ty Type))
))


(type CsrOP(enum 
  (Csrrw)
  (Csrrs)
  (Csrrc)
  (Csrrwi)
  (Csrrsi)
  (Csrrci)
))


(type I128OP (enum 
  (Add)
  (Sub)
  (Mul)
  (Div)
  (Rem)
  (Ishl)
  (Ushr)
  (Sshr)
  (Rotl)
  (Rotr)
  (Xnor)
  (Orn)
  (Cls)
))



(type IntSelectOP (enum
  (Imax)
  (Umax)
  (Imin)
  (Umin)
))


(type ReferenceValidOP(enum
  (IsNull)
  (IsInvalid)
))

(type AtomicOP (enum
  (LrW)
  (ScW)
  (AmoswapW)
  (AmoaddW)
  (AmoxorW)
  (AmoandW)
  (AmoorW)
  (AmominW)
  (AmomaxW)
  (AmominuW)
  (AmomaxuW)
  (LrD)
  (ScD)
  (AmoswapD)
  (AmoaddD)
  (AmoxorD)
  (AmoandD)
  (AmoorD)
  (AmominD)
  (AmomaxD)
  (AmominuD)
  (AmomaxuD)
))

(type FloatFlagOp (enum 
  (Frcsr)
  (Frrm)
  (Frflags)
  (Fsrmi)
  (Fsflagsi)
  (Fscsr)
  (Fsrm)
  (Fsflags)
))

(type AluOPRRRR(enum 
  ;; float32
  (FmaddS)
  (FmsubS)
  (FnmsubS)
  (FnmaddS)
  ;; float64
  (FmaddD)
  (FmsubD)
  (FnmsubD)
  (FnmaddD)
))

(type FClassResult(enum 
  ;;0 rs1 is −∞.
  (NegInfinite)
  ;; 1 rs1 is a negative normal number.
  (NegNormal)
  ;; 2 rs1 is a negative subnormal number.
  (NegSubNormal)
  ;; 3 rs1 is −0.
  (NegZero)
  ;; 4 rs1 is +0.
  (PosZero)
  ;; 5 rs1 is a positive subnormal number.
  (PosSubNormal)
  ;; 6 rs1 is a positive normal number.
  (PosNormal)
  ;; 7 rs1 is +∞.
  (PosInfinite)
  ;; 8 rs1 is a signaling NaN.
  (SNaN)
  ;; 9 rs1 is a quiet NaN.
  (QNaN)
))

(type AluOPRR (enum 
  ;; RV32F Standard Extension
  (FsqrtS)
  (FcvtWS)
  (FcvtWuS)
  (FmvXW)
  (FclassS)
  (FcvtSw)
  (FcvtSwU)
  (FmvWX)



  ;; RV64F Standard Extension (in addition to RV32F)
  (FcvtLS)
  (FcvtLuS)
  (FcvtSL)
  (FcvtSLU)
  

  ;; RV64D Standard Extension (in addition to RV32D)
  (FcvtLd)
  (FcvtLuD)
  (FmvXD)
  (FcvtDL)
  (FcvtDLu)
  (FmvDX)

  ;; RV32D Standard Extension
  (FsqrtD)
  (FcvtSd)
  (FcvtDS)
  (FclassD)
  (FcvtWD)
  (FcvtWuD)
  (FcvtDW)
  (FcvtDWU)
  
  ;; bitmapip
  
))

(type LoadOP (enum  
  (Lb)
  (Lh)
  (Lw)
  (Lbu)
  (Lhu)
  (Lwu)
  (Ld)
  (Flw)
  (Fld)
))

(type StoreOP(enum
  (Sb)
  (Sh)
  (Sw)
  (Sd)
  (Fsw)
  (Fsd)
))

(type AluOPRRR (enum 
  ;; base set
  (Add)
  (Sub)
  (Sll)
  (Slt)
  (SltU)
  (Xor)
  (Srl)
  (Sra)
  (Or)
  (And)
  
  ;; RV64I Base Instruction Set (in addition to RV32I)
  (Addw)
  (Subw)
  (Sllw)
  (Srlw)
  (Sraw)

  
  
  ;;RV32M Standard Extension
  (Mul)
  (Mulh)
  (Mulhsu)
  (Mulhu)
  (Div)
  (DivU)
  (Rem)
  (RemU)

  ;; RV64M Standard Extension (in addition to RV32M)

  (Mulw)
  (Divw)
  (Divuw)
  (Remw)
  (Remuw)

  ;; RV32F Standard Extension

  (FaddS)
  (FsubS)
  (FmulS)
  (FdivS)

  (FsgnjS)
  (FsgnjnS)
  (FsgnjxS)
  (FminS)
  (FmaxS)
  (FeqS)
  (FltS)
  (FleS)
 
  ;; RV32D Standard Extension
  (FaddD)
  (FsubD)
  (FmulD)
  (FdivD)
  (FsgnjD)
  (FsgnjnD)
  (FsgnjxD)
  (FminD)
  (FmaxD)
  (FeqD)
  (FltD)
  (FleD)

  ;; bitmapip
  (Adduw)
  (Andn)
  (Bclr)
  (Bext)
  (Binv)
  (Bset)
  (Clmul)
  (Clmulh)
  (Clmulr)
  (Max)
  (Maxu)
  (Min)
  (Minu)
  (Orn)
  (Rol)
  (Rolw)
  (Ror)
  (Rorw)
  (Sh1add)
  (Sh1adduw)
  (Sh2add)
  (Sh2adduw)
  (Sh3add)
  (Sh3adduw)
  (Xnor)

))


(type AluOPRRI (enum 
  (Addi)
  (Slti)
  (SltiU)
  (Xori)
  (Ori)
  (Andi)
  (Slli)
  (Srli)
  (Srai)
  (Addiw)
  (Slliw)
  (SrliW)
  (Sraiw)
  (Bclri)
  (Bexti)
  (Binvi)
  (Bseti)
  (Rori)
  (Roriw)
  (SlliUw)
  (Clz)
  (Clzw)
  (Cpop)
  (Cpopw)
  (Ctz)
  (Ctzw)
  (Rev8)
  (Sextb)
  (Sexth)
  (Zexth)
  (Orcb)
))

;; The 2-bit floating-point format field fmt is encoded as shown in Table 8.3. It is set to S (00) for all
;; instructions in the F extension.
(type OPFPFMT (enum 
  ;; 32-bit single-precision
  (S)
  ;;64-bit double-precision
  (D)
  ;; reserved
  ;;(Reserved)
  ;; 128-bit quad-precision
  (Q)
)) 


(type FloatRoundingMode (enum 
  ;; Round to Nearest, ties to Even
  (RNE)
  ;; Round towards Zero
  (RTZ)
  ;;  Round Down (towards −∞)
  (RDN)
  ;; Round Up (towards +∞)
  (RUP)
  ;; Round to Nearest, ties to Max Magnitude
  (RMM)
))

(type FFlagsException (enum
  ;; Invalid Operation
  (NV)
  ;; Divide by Zero
  (DZ)
  ;; Overflow
  (OF)
  ;; Underflow
  (UF)
  ;; Inexact
  (NX)
))


(type VecBranchTarget (primitive VecBranchTarget))
(type BoxCallInfo (primitive BoxCallInfo))
(type BoxCallIndInfo (primitive BoxCallIndInfo))
(type IntegerCompare (primitive IntegerCompare))
(type AMode (primitive AMode))
(type OptionReg (primitive OptionReg))
(type OptionImm12 (primitive OptionImm12))
(type OptionUimm5 (primitive OptionUimm5))
(type Imm12 (primitive Imm12))
(type UImm5 (primitive UImm5))
(type Imm20 (primitive Imm20))
(type Imm3 (primitive Imm3))
(type BranchTarget (primitive BranchTarget))
(type CsrAddress (primitive CsrAddress))
(type ExtendOp 
  (enum
    (UXTB)
    (UXTH)
    (UXTW)
    (UXTD)
    (SXTB)
    (SXTH)
    (SXTW)
    (SXTD)
))

(type Cond  
  (enum
    (Eq)
    (Ne)
    (Lt)
    (Ltu)
    (Ge)
    (Geu)
))


;; Helper for creating the zero register.
(decl zero_reg () Reg)
(extern constructor zero_reg zero_reg)

;; for load immediate
(decl imm (Type u64) Reg)
(extern constructor imm imm)

;; for load immediate
(decl imm_from_bits (u64) Imm12)
(extern constructor imm_from_bits imm_from_bits)

(decl imm_from_neg_bits (i64) Imm12)
(extern constructor imm_from_neg_bits imm_from_neg_bits)
;;
(decl imm12_from_u64 (Imm12) u64)
(extern extractor imm12_from_u64 imm12_from_u64)


(decl writable_zero_reg () WritableReg)
(extern constructor writable_zero_reg writable_zero_reg)

;; Helper for emitting `MInst.AluRR` instructions.
(decl alu_rr (AluOPRR Reg) Reg)
(rule (alu_rr op src )
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRR op dst src))))
        dst))


;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrr (AluOPRRR Reg Reg) Reg)
(rule (alu_rrr op src1 src2)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRR op dst src1 src2))))
        dst))


;; Helper for emitting `MInst.AluRRR` instructions.
(decl alu_rrrr (AluOPRRRR Reg Reg Reg) Reg)
(rule (alu_rrrr op src1 src2 src3)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRRR op dst src1 src2 src3))))
        dst))


;; Helper for emitting `MInst.AluRRImm12` instructions.
(decl alu_rr_imm12 (AluOPRRI Reg Imm12) Reg)
(rule (alu_rr_imm12 op src imm)
      (let ((dst WritableReg (temp_writable_reg $I64))
            (_ Unit (emit (MInst.AluRRImm12 op dst src imm))))
        dst))

(decl bitmaip_imm12 (AluOPRRI u8) Imm12)
(extern constructor bitmaip_imm12 bitmaip_imm12)

(decl alu_rr_imm12_bit_map (AluOPRRI Reg u8) Reg)
(rule (alu_rr_imm12_bit_map op src shamt)
      (alu_rr_imm12 op src (bitmaip_imm12 op shamt)))


;; Helper for narrow down int to it's bits.
(decl narrow_int(Type Reg) Reg)
(rule (narrow_int $I8 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 56)) (imm_from_bits 56))) 
(rule (narrow_int $I16 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 48)) (imm_from_bits 48)))
(rule (narrow_int $I32 r) (
  alu_rr_imm12 (AluOPRRI.Srli) (alu_rr_imm12 (AluOPRRI.Slli) r (imm_from_bits 32)) (imm_from_bits 32)))

;; Helper for get negative of Imm12 
(decl neg_imm12 (Imm12) Imm12)
(extern constructor neg_imm12 neg_imm12) 


;; Helper to go directly from a `Value`, when it's an `iconst`, to an `Imm12`.
(decl imm12_from_value (Imm12) Value)
(extractor
  (imm12_from_value n)
  (def_inst (iconst (u64_from_imm64 (imm12_from_u64 n)))))

(decl select_addi (Type) AluOPRRI)
(rule (select_addi (fits_in_32 ty)) (AluOPRRI.Addiw))
(rule (select_addi (fits_in_64 ty)) (AluOPRRI.Addi))

(decl float_bnot (Type  Reg) Reg)
(extern constructor float_bnot float_bnot)

(decl bnot_128 (ValueRegs) ValueRegs)
(extern constructor bnot_128 bnot_128)


(decl i128_arithmetic (I128OP ValueRegs ValueRegs) ValueRegs)
(extern constructor i128_arithmetic i128_arithmetic)

(decl lower_bit_reverse (Type Reg)Reg)
(extern constructor lower_bit_reverse lower_bit_reverse)

(decl lower_ctz (Type ValueRegs)ValueRegs)
(extern constructor lower_ctz lower_ctz)

(decl lower_clz (Type ValueRegs)Reg)
(extern constructor lower_clz lower_clz)

(decl lower_extend(Reg bool u8 u8 )ValueRegs)
(extern constructor lower_extend lower_extend)

(decl band_not_128(ValueRegs ValueRegs)ValueRegs)
(extern constructor band_not_128 band_not_128)


(decl b128_binary(AluOPRRR ValueRegs ValueRegs) ValueRegs)
(extern constructor b128_binary b128_binary)

(decl lower_mlhi (bool Type Reg Reg)Reg)
(extern constructor lower_mlhi lower_mlhi)


(decl lower_rotl(Type Reg Reg) Reg)
(extern constructor lower_rotl lower_rotl)
(decl lower_rotr(Type Reg Reg) Reg)
(extern constructor lower_rotr lower_rotr)

(decl lower_cls(ValueRegs Type) Reg)
(extern constructor lower_cls lower_cls)