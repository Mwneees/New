(type Inst (primitive Inst))

;; Helper used in generated extractors for each CLIF instruction to extract
;; information from an `Inst`.
(decl inst_data (InstructionData) Inst)
(extern extractor infallible inst_data inst_data)

;; Helper used to perform an `ins()` operation which inserts just before the
;; current instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `ins_*` prefix.
(decl ins (Type InstructionData) Inst)
(extern constructor ins ins)

;; Helper used to perform a `replace()` operation which replaces the current
;; instruction being legalized.
;;
;; This is invoked by generated constructors for each CLIF instruction with the
;; `replace_*` prefix.
(decl replace (Type InstructionData) Inst)
(extern constructor replace replace)

;; Constructors for value arrays.
(decl value_array_2_ctor (Value Value) ValueArray2)
(extern constructor value_array_2_ctor value_array_2_ctor)
(decl value_array_3_ctor (Value Value Value) ValueArray3)
(extern constructor value_array_3_ctor value_array_3_ctor)

(decl pure first_result (Inst) Value)
(extern constructor first_result first_result)
(convert Inst Value first_result)

(decl has_type (Type Inst) Inst)
(extractor (has_type ty inst) (and (result_type ty) inst))
(decl result_type (Type) Inst)
(extern extractor result_type result_type)

;; Helper to generate an `iconst` value which has type `I64` and the provided
;; value.
(decl ins_i64 (i64) Value)
(rule (ins_i64 val) (ins_iconst $I64 (imm64 (i64_as_u64 val))))

;; Optionally "legalize" an instruction to a new instruction.
;;
;; This is used to transform CLIF into something which can be handled by each
;; individual backend. There is both common functionality of legalization for
;; all backends in addition to backend-specific legalization.
(decl partial legalize (Inst) Inst)

;; Transform extend-to-i128 to an `iconcat` instruction
(rule 0 (legalize (has_type $I128 (uextend x @ (value_type (fits_in_32 _)))))
  (replace_iconcat $I64 (ins_uextend $I64 x) (ins_i64 0)))
(rule 1 (legalize (has_type $I128 (uextend x @ (value_type $I64))))
  (replace_iconcat $I64 x (ins_i64 0)))
(rule 0 (legalize (has_type $I128 (sextend x @ (value_type (fits_in_32 _)))))
  (let ((val64 Value (ins_sextend $I64 x)))
    (replace_iconcat $I64 val64 (ins_sshr $I64 val64 (ins_i64 63)))))
(rule 1 (legalize (has_type $I128 (sextend x @ (value_type $I64))))
  (replace_iconcat $I64 x (ins_sshr $I64 x (ins_i64 63))))
