// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - D:\projects\wasmtime\target\debug\build\cranelift-codegen-bc96f3d19b0bb9bb\out\clif.isle
// - src\prelude.isle
// - src\isa\riscv64\inst.isle
// - src\isa\riscv64\lower.isle

use super::*; // Pulls in all external types.

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> Option<u32>;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn value_regs_invalid(&mut self) -> ValueRegs;
    fn output_none(&mut self) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_builder_new(&mut self) -> InstOutputBuilder;
    fn output_builder_push(&mut self, arg0: &InstOutputBuilder, arg1: ValueRegs) -> Unit;
    fn output_builder_finish(&mut self, arg0: &InstOutputBuilder) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn invalid_reg_etor(&mut self, arg0: Reg) -> Option<()>;
    fn invalid_reg(&mut self) -> Reg;
    fn valid_reg(&mut self, arg0: Reg) -> Option<()>;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn u8_as_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_as_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u16_as_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u32_as_u64(&mut self, arg0: u32) -> Option<u64>;
    fn i64_as_u64(&mut self, arg0: i64) -> Option<u64>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn ty_bits(&mut self, arg0: Type) -> Option<u8>;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_bool_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_bool_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_bool_128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data(&mut self, arg0: Inst) -> InstructionData;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u8, u16)>;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn avoid_div_traps(&mut self, arg0: Type) -> Option<()>;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn symbol_value_data(
        &mut self,
        arg0: GlobalValue,
    ) -> Option<(ExternalName, RelocDistance, i64)>;
    fn reloc_distance_near(&mut self, arg0: RelocDistance) -> Option<()>;
    fn zero_reg(&mut self) -> Reg;
    fn imm(&mut self, arg0: Type, arg1: u64) -> Reg;
    fn imm_from_bits(&mut self, arg0: u64) -> Imm12;
    fn imm_from_neg_bits(&mut self, arg0: i64) -> Imm12;
    fn imm12_from_u64(&mut self, arg0: u64) -> Option<Imm12>;
    fn writable_zero_reg(&mut self) -> WritableReg;
    fn neg_imm12(&mut self, arg0: Imm12) -> Imm12;
    fn float_bnot(&mut self, arg0: Type, arg1: Reg) -> Reg;
    fn bnot_128(&mut self, arg0: ValueRegs) -> ValueRegs;
    fn band_128(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> ValueRegs;
    fn i128_arithmetic(
        &mut self,
        arg0: &I128ArithmeticOP,
        arg1: ValueRegs,
        arg2: ValueRegs,
    ) -> ValueRegs;
}

/// Internal type SideEffectNoResult: defined at src\prelude.isle line 457.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst { inst: MInst },
    Inst2 { inst1: MInst, inst2: MInst },
}

/// Internal type ProducesFlags: defined at src\prelude.isle line 484.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    ProducesFlagsSideEffect { inst: MInst },
    ProducesFlagsReturnsReg { inst: MInst, result: Reg },
    ProducesFlagsReturnsResultWithConsumer { inst: MInst, result: Reg },
}

/// Internal type ConsumesFlags: defined at src\prelude.isle line 495.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src\isa\riscv64\inst.isle line 2.
#[derive(Clone, Debug)]
pub enum MInst {
    Nop0,
    Nop4,
    Lui {
        rd: WritableReg,
        imm: Imm20,
    },
    Auipc {
        rd: WritableReg,
        imm: Imm20,
    },
    AluRR {
        alu_op: AluOPRR,
        rd: WritableReg,
        rs: Reg,
    },
    AluRRR {
        alu_op: AluOPRRR,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
    },
    AluRRRR {
        alu_op: AluOPRRRR,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        rs3: Reg,
    },
    AluRRImm12 {
        alu_op: AluOPRRI,
        rd: WritableReg,
        rs: Reg,
        imm12: Imm12,
    },
    Load {
        rd: WritableReg,
        op: LoadOP,
        flags: MemFlags,
        from: AMode,
    },
    Store {
        to: AMode,
        op: StoreOP,
        flags: MemFlags,
        src: Reg,
    },
    EpiloguePlaceholder,
    Ret,
    Extend {
        rd: WritableReg,
        rn: Reg,
        signed: bool,
        from_bits: u8,
        to_bits: u8,
    },
    AjustSp {
        amount: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    CallInd {
        info: BoxCallIndInfo,
    },
    TrapIf {
        rs1: Reg,
        rs2: Reg,
        cond: Cond,
        trap_code: TrapCode,
    },
    Trap {
        trap_code: TrapCode,
    },
    Jal {
        rd: WritableReg,
        dest: BranchTarget,
    },
    CondBr {
        taken: BranchTarget,
        not_taken: BranchTarget,
        kind: IntegerCompare,
    },
    LoadExtName {
        rd: WritableReg,
        name: BoxExternalName,
        offset: i64,
    },
    LoadAddr {
        rd: WritableReg,
        mem: AMode,
    },
    VirtualSPOffsetAdj {
        amount: i64,
    },
    Mov {
        rd: WritableReg,
        rm: Reg,
        ty: Type,
    },
    Fence,
    FenceI,
    ECall,
    EBreak,
    Udf {
        trap_code: TrapCode,
    },
    FloatFlagOperation {
        op: FloatFlagOp,
        rd: WritableReg,
        rs: OptionReg,
        imm: OptionImm12,
    },
    Jalr {
        rd: WritableReg,
        base: Reg,
        offset: Imm12,
    },
    Atomic {
        op: AtomicOP,
        rd: WritableReg,
        addr: Reg,
        src: Reg,
        aq: bool,
        rl: bool,
    },
    Ffcmp {
        rd: WritableReg,
        cc: FloatCC,
        ty: Type,
        rs1: Reg,
        rs2: Reg,
    },
    Select {
        dst: VecWritableReg,
        ty: Type,
        conditon: Reg,
        x: ValueRegs,
        y: ValueRegs,
    },
    ReferenceValid {
        rd: WritableReg,
        op: ReferenceValidOP,
        x: Reg,
    },
    BrTable {
        index: Reg,
        tmp1: WritableReg,
        default_: BranchTarget,
        targets: VecBranchTarget,
    },
    AtomicCas {
        t0: WritableReg,
        dst: WritableReg,
        e: Reg,
        addr: Reg,
        v: Reg,
        ty: Type,
    },
    IntSelect {
        op: IntSelectOP,
        dst: VecWritableReg,
        x: ValueRegs,
        y: ValueRegs,
        ty: Type,
    },
    I128Arithmetic {
        op: I128ArithmeticOP,
        t0: WritableReg,
        t1: WritableReg,
        dst: VecWritableReg,
        x: ValueRegs,
        y: ValueRegs,
    },
    Csr {
        csr_op: CsrOP,
        rd: WritableReg,
        rs: OptionReg,
        imm: OptionUimm5,
        csr: CsrAddress,
    },
}

/// Internal type CsrOP: defined at src\isa\riscv64\inst.isle line 221.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum CsrOP {
    Csrrw,
    Csrrs,
    Csrrc,
    Csrrwi,
    Csrrsi,
    Csrrci,
}

/// Internal type I128ArithmeticOP: defined at src\isa\riscv64\inst.isle line 231.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum I128ArithmeticOP {
    Add,
    Sub,
    Mul,
    Div,
    Rem,
}

/// Internal type IntSelectOP: defined at src\isa\riscv64\inst.isle line 241.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum IntSelectOP {
    Imax,
    Umax,
    Imin,
    Umin,
}

/// Internal type ReferenceValidOP: defined at src\isa\riscv64\inst.isle line 249.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ReferenceValidOP {
    IsNull,
    IsInvalid,
}

/// Internal type AtomicOP: defined at src\isa\riscv64\inst.isle line 254.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AtomicOP {
    LrW,
    ScW,
    AmoswapW,
    AmoaddW,
    AmoxorW,
    AmoandW,
    AmoorW,
    AmominW,
    AmomaxW,
    AmominuW,
    AmomaxuW,
    LrD,
    ScD,
    AmoswapD,
    AmoaddD,
    AmoxorD,
    AmoandD,
    AmoorD,
    AmominD,
    AmomaxD,
    AmominuD,
    AmomaxuD,
}

/// Internal type FloatFlagOp: defined at src\isa\riscv64\inst.isle line 279.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatFlagOp {
    Frcsr,
    Frrm,
    Frflags,
    Fsrmi,
    Fsflagsi,
    Fscsr,
    Fsrm,
    Fsflags,
}

/// Internal type AluOPRRRR: defined at src\isa\riscv64\inst.isle line 290.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRRR {
    FmaddS,
    FmsubS,
    FnmsubS,
    FnmaddS,
    FmaddD,
    FmsubD,
    FnmsubD,
    FnmaddD,
}

/// Internal type FClassResult: defined at src\isa\riscv64\inst.isle line 303.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FClassResult {
    NegInfinite,
    NegNormal,
    NegSubNormal,
    NegZero,
    PosZero,
    PosSubNormal,
    PosNormal,
    PosInfinite,
    SNaN,
    QNaN,
}

/// Internal type AluOPRR: defined at src\isa\riscv64\inst.isle line 326.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRR {
    FsqrtS,
    FcvtWS,
    FcvtWuS,
    FmvXW,
    FclassS,
    FcvtSw,
    FcvtSwU,
    FmvWX,
    FcvtLS,
    FcvtLuS,
    FcvtSL,
    FcvtSLU,
    FcvtLd,
    FcvtLuD,
    FmvXD,
    FcvtDL,
    FcvtDLu,
    FmvDX,
    FsqrtD,
    FcvtSd,
    FcvtDS,
    FclassD,
    FcvtWD,
    FcvtWuD,
    FcvtDW,
    FcvtDWU,
}

/// Internal type LoadOP: defined at src\isa\riscv64\inst.isle line 368.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum LoadOP {
    Lb,
    Lh,
    Lw,
    Lbu,
    Lhu,
    Lwu,
    Ld,
    Flw,
    Fld,
}

/// Internal type StoreOP: defined at src\isa\riscv64\inst.isle line 380.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum StoreOP {
    Sb,
    Sh,
    Sw,
    Sd,
    Fsw,
    Fsd,
}

/// Internal type AluOPRRR: defined at src\isa\riscv64\inst.isle line 389.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRR {
    Add,
    Sub,
    Sll,
    Slt,
    SltU,
    Xor,
    Srl,
    Sra,
    Or,
    And,
    Addw,
    Subw,
    Sllw,
    Srlw,
    Sraw,
    Mul,
    Mulh,
    Mulhsu,
    Mulhu,
    Div,
    DivU,
    Rem,
    RemU,
    Mulw,
    Divw,
    Divuw,
    Remw,
    Remuw,
    FaddS,
    FsubS,
    FmulS,
    FdivS,
    FsgnjS,
    FsgnjnS,
    FsgnjxS,
    FminS,
    FmaxS,
    FeqS,
    FltS,
    FleS,
    FaddD,
    FsubD,
    FmulD,
    FdivD,
    FsgnjD,
    FsgnjnD,
    FsgnjxD,
    FminD,
    FmaxD,
    FeqD,
    FltD,
    FleD,
    Adduw,
    Andn,
    Bclr,
    Bext,
    Binv,
    Bset,
    Clmul,
    Clmulh,
    Clmulr,
    Max,
    Maxu,
    Min,
    Minu,
    Orn,
    Rol,
    Rolw,
    Ror,
    Rorw,
    Sh1add,
    Sh1adduw,
    Sh2add,
    Sh2adduw,
    Sh3add,
    Sh3adduw,
    Xnor,
}

/// Internal type AluOPRRI: defined at src\isa\riscv64\inst.isle line 489.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRI {
    Addi,
    Slti,
    SltiU,
    Xori,
    Ori,
    Andi,
    Slli,
    Srli,
    Srai,
    Addiw,
    Slliw,
    SrliW,
    Sraiw,
    Bclri,
    Bexti,
    Binvi,
    Bseti,
    Rori,
    Roriw,
    SlliUw,
    Clz,
    Clzw,
    Cpop,
    Cpopw,
    Ctz,
    Ctzw,
    Rev8,
    Sextb,
    Sexth,
    Zexth,
    Orcb,
}

/// Internal type OPFPFMT: defined at src\isa\riscv64\inst.isle line 525.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum OPFPFMT {
    S,
    D,
    Q,
}

/// Internal type FloatRoundingMode: defined at src\isa\riscv64\inst.isle line 537.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatRoundingMode {
    RNE,
    RTZ,
    RDN,
    RUP,
    RMM,
}

/// Internal type FFlagsException: defined at src\isa\riscv64\inst.isle line 550.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FFlagsException {
    NV,
    DZ,
    OF,
    UF,
    NX,
}

/// Internal type ExtendOp: defined at src\isa\riscv64\inst.isle line 578.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ExtendOp {
    UXTB,
    UXTH,
    UXTW,
    UXTD,
    SXTB,
    SXTH,
    SXTW,
    SXTD,
}

/// Internal type Cond: defined at src\isa\riscv64\inst.isle line 590.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum Cond {
    Eq,
    Ne,
    Lt,
    Ltu,
    Ge,
    Geu,
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(ctx: &mut C, arg0: Reg) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src\prelude.isle line 113.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(ctx: &mut C, arg0: Value) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    // Rule at src\prelude.isle line 117.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(ctx: &mut C, arg0: Type) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src\prelude.isle line 137.
    let expr0_0 = C::temp_writable_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return Some(expr1_0);
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(ctx: &mut C, arg0: Value) -> Option<Reg> {
    let pattern0_0 = arg0;
    // Rule at src\prelude.isle line 182.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            // Rule at src\prelude.isle line 465.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::output_none(ctx);
            return Some(expr1_0);
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            // Rule at src\prelude.isle line 468.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::output_none(ctx);
            return Some(expr2_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> Option<SideEffectNoResult> {
    let pattern0_0 = arg0;
    if let &SideEffectNoResult::Inst {
        inst: ref pattern1_0,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        if let &SideEffectNoResult::Inst {
            inst: ref pattern3_0,
        } = pattern2_0
        {
            // Rule at src\prelude.isle line 474.
            let expr0_0 = SideEffectNoResult::Inst2 {
                inst1: pattern1_0.clone(),
                inst2: pattern3_0.clone(),
            };
            return Some(expr0_0);
        }
    }
    return None;
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsReturnsReg {
        inst: ref pattern1_0,
        result: pattern1_1,
    } = pattern0_0
    {
        // Rule at src\prelude.isle line 511.
        return Some(pattern1_1);
    }
    return None;
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Option<ProducesFlags> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src\prelude.isle line 516.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src\prelude.isle line 518.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return Some(expr0_0);
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> Option<ConsumesFlags> {
    let pattern0_0 = arg0;
    if let &ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: ref pattern1_0,
        result: pattern1_1,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        if let &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref pattern3_0,
            result: pattern3_1,
        } = pattern2_0
        {
            // Rule at src\prelude.isle line 525.
            let expr0_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
            let expr1_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                inst1: pattern1_0.clone(),
                inst2: pattern3_0.clone(),
                result: expr0_0,
            };
            return Some(expr1_0);
        }
    }
    return None;
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<ValueRegs> {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src\prelude.isle line 550.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern3_1);
                    return Some(expr2_0);
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src\prelude.isle line 556.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    return Some(pattern3_2);
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src\prelude.isle line 568.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    let expr3_0 = C::emit(ctx, pattern3_2);
                    let expr4_0 = C::emit(ctx, pattern3_3);
                    return Some(pattern3_4);
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                inst: ref pattern3_0,
                result: pattern3_1,
            } = pattern2_0
            {
                // Rule at src\prelude.isle line 544.
                let expr0_0 = C::emit(ctx, pattern1_0);
                let expr1_0 = C::emit(ctx, pattern3_0);
                let expr2_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                return Some(expr2_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src\prelude.isle line 585.
    let expr0_0 = constructor_with_flags(ctx, pattern0_0, pattern1_0)?;
    let expr1_0: usize = 0;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return Some(expr2_0);
}

// Generated as internal constructor for term alu_rr.
pub fn constructor_alu_rr<C: Context>(ctx: &mut C, arg0: &AluOPRR, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src\isa\riscv64\inst.isle line 625.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRR {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_rrr.
pub fn constructor_alu_rrr<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: Reg,
    arg2: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src\isa\riscv64\inst.isle line 633.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRR {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_rrrr.
pub fn constructor_alu_rrrr<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRRR,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src\isa\riscv64\inst.isle line 641.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRRR {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
        rs3: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term alu_rr_imm12.
pub fn constructor_alu_rr_imm12<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRI,
    arg1: Reg,
    arg2: Imm12,
) -> Option<Reg> {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src\isa\riscv64\inst.isle line 649.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRImm12 {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
        imm12: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return Some(expr4_0);
}

// Generated as internal constructor for term narrow_int.
pub fn constructor_narrow_int<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Option<Reg> {
    let pattern0_0 = arg0;
    if pattern0_0 == I8 {
        let pattern2_0 = arg1;
        // Rule at src\isa\riscv64\inst.isle line 656.
        let expr0_0 = AluOPRRI::Srli;
        let expr1_0 = AluOPRRI::Slli;
        let expr2_0: u64 = 56;
        let expr3_0 = C::imm_from_bits(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr1_0, pattern2_0, expr3_0)?;
        let expr5_0: u64 = 56;
        let expr6_0 = C::imm_from_bits(ctx, expr5_0);
        let expr7_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr4_0, expr6_0)?;
        return Some(expr7_0);
    }
    if pattern0_0 == I16 {
        let pattern2_0 = arg1;
        // Rule at src\isa\riscv64\inst.isle line 658.
        let expr0_0 = AluOPRRI::Srli;
        let expr1_0 = AluOPRRI::Slli;
        let expr2_0: u64 = 48;
        let expr3_0 = C::imm_from_bits(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr1_0, pattern2_0, expr3_0)?;
        let expr5_0: u64 = 48;
        let expr6_0 = C::imm_from_bits(ctx, expr5_0);
        let expr7_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr4_0, expr6_0)?;
        return Some(expr7_0);
    }
    return None;
}

// Generated as internal constructor for term select_addi.
pub fn constructor_select_addi<C: Context>(ctx: &mut C, arg0: Type) -> Option<AluOPRRI> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_32(ctx, pattern0_0) {
        // Rule at src\isa\riscv64\inst.isle line 674.
        let expr0_0 = AluOPRRI::Addiw;
        return Some(expr0_0);
    }
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        // Rule at src\isa\riscv64\inst.isle line 675.
        let expr0_0 = AluOPRRI::Addi;
        return Some(expr0_0);
    }
    return None;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: Inst) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == B128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Band = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src\isa\riscv64\lower.isle line 145.
                        let expr0_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr2_0 = C::band_128(ctx, expr0_0, expr1_0);
                        let expr3_0 = C::output(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                }
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Bnot = pattern5_0 {
                        // Rule at src\isa\riscv64\lower.isle line 189.
                        let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                        let expr1_0 = C::bnot_128(ctx, expr0_0);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 45.
                            let expr0_0 = I128ArithmeticOP::Add;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 = C::i128_arithmetic(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 68.
                            let expr0_0 = I128ArithmeticOP::Sub;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 = C::i128_arithmetic(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 95.
                            let expr0_0 = I128ArithmeticOP::Mul;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 = C::i128_arithmetic(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 147.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = C::band_128(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Bnot = pattern5_0 {
                        // Rule at src\isa\riscv64\lower.isle line 187.
                        let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                        let expr1_0 = C::bnot_128(ctx, expr0_0);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Unary {
                opcode: ref pattern5_0,
                arg: pattern5_1,
            } = &pattern4_0
            {
                if let &Opcode::Bnot = pattern5_0 {
                    // Rule at src\isa\riscv64\lower.isle line 179.
                    let expr0_0: Type = F32;
                    let expr1_0 = C::put_in_reg(ctx, pattern5_1);
                    let expr2_0 = C::float_bnot(ctx, expr0_0, expr1_0);
                    let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                    return Some(expr3_0);
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::NullAry {
                opcode: ref pattern4_0,
            } => {
                if let &Opcode::Null = pattern4_0 {
                    // Rule at src\isa\riscv64\lower.isle line 23.
                    let expr0_0: u64 = 0;
                    let expr1_0 = C::imm(ctx, pattern2_0, expr0_0);
                    let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                    return Some(expr2_0);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref pattern4_0,
                imm: pattern4_1,
            } => {
                if let &Opcode::Iconst = pattern4_0 {
                    let pattern6_0 = C::u64_from_imm64(ctx, pattern4_1);
                    // Rule at src\isa\riscv64\lower.isle line 9.
                    let expr0_0 = C::imm(ctx, pattern2_0, pattern6_0);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0)?;
                    return Some(expr1_0);
                }
            }
            &InstructionData::UnaryBool {
                opcode: ref pattern4_0,
                imm: pattern4_1,
            } => {
                if let &Opcode::Bconst = pattern4_0 {
                    if pattern4_1 == true {
                        // Rule at src\isa\riscv64\lower.isle line 17.
                        let expr0_0: u64 = 1;
                        let expr1_0 = C::imm(ctx, pattern2_0, expr0_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                    if pattern4_1 == false {
                        // Rule at src\isa\riscv64\lower.isle line 14.
                        let expr0_0: u64 = 0;
                        let expr1_0 = C::imm(ctx, pattern2_0, expr0_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0)?;
                        return Some(expr2_0);
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                if let &Opcode::Bnot = pattern4_0 {
                    // Rule at src\isa\riscv64\lower.isle line 184.
                    let expr0_0 = AluOPRRI::Xori;
                    let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr2_0: i64 = -1;
                    let expr3_0 = C::imm_from_neg_bits(ctx, expr2_0);
                    let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0)?;
                    let expr5_0 = constructor_output_reg(ctx, expr4_0)?;
                    return Some(expr5_0);
                }
            }
            _ => {}
        }
        if let Some(pattern3_0) = C::fits_in_16(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Udiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src\isa\riscv64\lower.isle line 101.
                        let expr0_0 = AluOPRRR::Divuw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_narrow_int(ctx, pattern3_0, expr1_0)?;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = constructor_narrow_int(ctx, pattern3_0, expr3_0)?;
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr2_0, expr4_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src\isa\riscv64\lower.isle line 122.
                        let expr0_0 = AluOPRRR::Remuw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = constructor_narrow_int(ctx, pattern3_0, expr1_0)?;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = constructor_narrow_int(ctx, pattern3_0, expr3_0)?;
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr2_0, expr4_0)?;
                        let expr6_0 = constructor_output_reg(ctx, expr5_0)?;
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 31.
                            let expr0_0 = AluOPRRR::Addw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 57.
                            let expr0_0 = AluOPRRR::Subw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 86.
                            let expr0_0 = AluOPRRR::Mulw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Udiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 107.
                            let expr0_0 = AluOPRRR::Divuw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 104.
                            let expr0_0 = AluOPRRR::Divw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Urem => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 125.
                            let expr0_0 = AluOPRRR::Remuw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Srem => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 119.
                            let expr0_0 = AluOPRRR::Remw;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Ineg = pattern5_0 {
                        // Rule at src\isa\riscv64\lower.isle line 78.
                        let expr0_0 = AluOPRRR::Subw;
                        let expr1_0 = C::zero_reg(ctx);
                        let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 42.
                                            let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 39.
                                            let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            // Rule at src\isa\riscv64\lower.isle line 35.
                            let expr0_0 = AluOPRRR::Add;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 65.
                                            let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = C::neg_imm12(ctx, pattern13_0);
                                            let expr3_0 = constructor_alu_rr_imm12(
                                                ctx, &expr0_0, expr1_0, expr2_0,
                                            )?;
                                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                                            return Some(expr4_0);
                                        }
                                    }
                                }
                            }
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 61.
                                            let expr0_0 = constructor_select_addi(ctx, pattern3_0)?;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = C::neg_imm12(ctx, pattern13_0);
                                            let expr3_0 = constructor_alu_rr_imm12(
                                                ctx, &expr0_0, expr1_0, expr2_0,
                                            )?;
                                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                                            return Some(expr4_0);
                                        }
                                    }
                                }
                            }
                            // Rule at src\isa\riscv64\lower.isle line 54.
                            let expr0_0 = AluOPRRR::Sub;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 84.
                            let expr0_0 = AluOPRRR::Mul;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Umulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 92.
                            let expr0_0 = AluOPRRR::Mulhsu;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Smulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 89.
                            let expr0_0 = AluOPRRR::Mulh;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Udiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 113.
                            let expr0_0 = AluOPRRR::DivU;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Sdiv => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 110.
                            let expr0_0 = AluOPRRR::Div;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Urem => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 131.
                            let expr0_0 = AluOPRRR::RemU;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Srem => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src\isa\riscv64\lower.isle line 128.
                            let expr0_0 = AluOPRRR::Rem;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 142.
                                            let expr0_0 = AluOPRRI::Andi;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 139.
                                            let expr0_0 = AluOPRRI::Andi;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            // Rule at src\isa\riscv64\lower.isle line 135.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 159.
                                            let expr0_0 = AluOPRRI::Ori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 156.
                                            let expr0_0 = AluOPRRI::Ori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            // Rule at src\isa\riscv64\lower.isle line 152.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 170.
                                            let expr0_0 = AluOPRRI::Xori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                                let pattern9_0 = C::inst_data(ctx, pattern8_0);
                                if let &InstructionData::UnaryImm {
                                    opcode: ref pattern10_0,
                                    imm: pattern10_1,
                                } = &pattern9_0
                                {
                                    if let &Opcode::Iconst = pattern10_0 {
                                        let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                        if let Some(pattern13_0) =
                                            C::imm12_from_u64(ctx, pattern12_0)
                                        {
                                            // Rule at src\isa\riscv64\lower.isle line 167.
                                            let expr0_0 = AluOPRRI::Xori;
                                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                            let expr2_0 = constructor_alu_rr_imm12(
                                                ctx,
                                                &expr0_0,
                                                expr1_0,
                                                pattern13_0,
                                            )?;
                                            let expr3_0 = constructor_output_reg(ctx, expr2_0)?;
                                            return Some(expr3_0);
                                        }
                                    }
                                }
                            }
                            // Rule at src\isa\riscv64\lower.isle line 163.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                            let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Ineg = pattern5_0 {
                        // Rule at src\isa\riscv64\lower.isle line 76.
                        let expr0_0 = AluOPRRR::Sub;
                        let expr1_0 = C::zero_reg(ctx);
                        let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0)?;
                        let expr4_0 = constructor_output_reg(ctx, expr3_0)?;
                        return Some(expr4_0);
                    }
                }
                _ => {}
            }
        }
    }
    return None;
}
